<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

        <title>黄杰的记事本</title>
        <link href="http://blog.linuxsand.info/atom.xml" rel="self" />
        <link href="http://blog.linuxsand.info" />
        <id>http://blog.linuxsand.info</id>
        <updated></updated>

        <entry>
                <title>NaiStudio 数字信号板</title>
                <link href="http://blog.linuxsand.info/naistudio-digital-io-board.html" />
                <id>http://blog.linuxsand.info/naistudio-digital-io-board.html</id>
                <updated>2019-11-25T22:22:22Z</updated>
                <content type="html">
                <![CDATA[
&lt;p&gt;（NaiStudio 是我的微信公号）&lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;RevA 版本的规格如下：&lt;/p&gt;&lt;p&gt;使用场景：&lt;/p&gt;&lt;p&gt;RevA 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;TODO 项：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;RevB 与 RevA 版本的规格区别：&lt;/p&gt;&lt;p&gt;RevB 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;这个版本开始，命名方式使用 &lt;/p&gt;&lt;p&gt;这个版本是打样迭代版本，主要规格：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;（为何直接从 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;上位机软件支持本页面所有列出的型号；它分为两个部分，一是“开箱即用”的实用工具（Utility），连接信号板后，能够快速刷新信号状态和强制数字信号输出（可批量连续测试输出通道）；
二为开发包（SDK），目前支持 &lt;/p&gt;&lt;p&gt;请到产品支持页 &lt;/p&gt;&lt;p&gt;将和我的朋友“涛哥工业科技（TaoRobotics）”联合量产，敬请期待。&lt;/p&gt;
                ]]>
        </content>
        </entry>

        <entry>
                <title>手动管理 PostgreSQL 数据库的分区表（二）</title>
                <link href="http://blog.linuxsand.info/partitions-manual-management-2-in-postgresql.html" />
                <id>http://blog.linuxsand.info/partitions-manual-management-2-in-postgresql.html</id>
                <updated>2019-11-25T22:22:22Z</updated>
                <content type="html">
                <![CDATA[
&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;RevA 版本的规格如下：&lt;/p&gt;&lt;p&gt;使用场景：&lt;/p&gt;&lt;p&gt;RevA 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;TODO 项：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;RevB 与 RevA 版本的规格区别：&lt;/p&gt;&lt;p&gt;RevB 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;这个版本开始，命名方式使用 &lt;/p&gt;&lt;p&gt;这个版本是打样迭代版本，主要规格：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;（为何直接从 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;上位机软件支持本页面所有列出的型号；它分为两个部分，一是“开箱即用”的实用工具（Utility），连接信号板后，能够快速刷新信号状态和强制数字信号输出（可批量连续测试输出通道）；
二为开发包（SDK），目前支持 &lt;/p&gt;&lt;p&gt;请到产品支持页 &lt;/p&gt;&lt;p&gt;将和我的朋友“涛哥工业科技（TaoRobotics）”联合量产，敬请期待。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;第一，用户在创建原生分区表时需用 &lt;/p&gt;&lt;p&gt;第二，手动创建子表和索引&lt;/p&gt;&lt;p&gt;我们在 psql 内查看父表和子表。（为了照顾页面宽度，删除了表格的部分栏位）&lt;/p&gt;&lt;p&gt;到这里就完成了。这是原生的分区表，不像上一篇用继承实现的分区表需要编写 function 和 trigger 来做父表到子表的重定向。&lt;/p&gt;&lt;p&gt;我们插入 32 条测试数据试一下。PG 返回 &lt;/p&gt;&lt;p&gt;再看看两张子表的行数量。分别为 22 行和 10 行，说明数据正确地写入了相应的子表。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。我们在原生分区表中手动新增子表是相对很方便了，因此只需在操作系统或者应用软件层面执行定时任务：在特定时机“拼接”出下面的 SQL 执行即可。&lt;/p&gt;&lt;p&gt;下面的代码用于移除子表。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了声明式分区（原生分区表）的基本操作、分区维护和优缺点。&lt;/p&gt;
                ]]>
        </content>
        </entry>

        <entry>
                <title>使用 pg_partman 自动管理 PostgreSQL 数据库的分区表</title>
                <link href="http://blog.linuxsand.info/partitions-automatic-management-in-postgresql-by-pg_partman.html" />
                <id>http://blog.linuxsand.info/partitions-automatic-management-in-postgresql-by-pg_partman.html</id>
                <updated>2019-11-25T22:22:22Z</updated>
                <content type="html">
                <![CDATA[
&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;RevA 版本的规格如下：&lt;/p&gt;&lt;p&gt;使用场景：&lt;/p&gt;&lt;p&gt;RevA 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;TODO 项：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;RevB 与 RevA 版本的规格区别：&lt;/p&gt;&lt;p&gt;RevB 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;这个版本开始，命名方式使用 &lt;/p&gt;&lt;p&gt;这个版本是打样迭代版本，主要规格：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;（为何直接从 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;上位机软件支持本页面所有列出的型号；它分为两个部分，一是“开箱即用”的实用工具（Utility），连接信号板后，能够快速刷新信号状态和强制数字信号输出（可批量连续测试输出通道）；
二为开发包（SDK），目前支持 &lt;/p&gt;&lt;p&gt;请到产品支持页 &lt;/p&gt;&lt;p&gt;将和我的朋友“涛哥工业科技（TaoRobotics）”联合量产，敬请期待。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;第一，用户在创建原生分区表时需用 &lt;/p&gt;&lt;p&gt;第二，手动创建子表和索引&lt;/p&gt;&lt;p&gt;我们在 psql 内查看父表和子表。（为了照顾页面宽度，删除了表格的部分栏位）&lt;/p&gt;&lt;p&gt;到这里就完成了。这是原生的分区表，不像上一篇用继承实现的分区表需要编写 function 和 trigger 来做父表到子表的重定向。&lt;/p&gt;&lt;p&gt;我们插入 32 条测试数据试一下。PG 返回 &lt;/p&gt;&lt;p&gt;再看看两张子表的行数量。分别为 22 行和 10 行，说明数据正确地写入了相应的子表。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。我们在原生分区表中手动新增子表是相对很方便了，因此只需在操作系统或者应用软件层面执行定时任务：在特定时机“拼接”出下面的 SQL 执行即可。&lt;/p&gt;&lt;p&gt;下面的代码用于移除子表。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了声明式分区（原生分区表）的基本操作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;前两篇文章（&lt;/p&gt;&lt;p&gt;本文记录了使用 &lt;/p&gt;&lt;p&gt;对于 Windows 用户，需要自己克隆代码（&lt;/p&gt;&lt;p&gt;构建后，预期得到的文件有：&lt;/p&gt;&lt;p&gt;但是阅读 &lt;/p&gt;&lt;p&gt;通过搜索 github issues，找到了&lt;/p&gt;&lt;p&gt;直接在 git bash 内执行 &lt;/p&gt;&lt;p&gt;把上一步得到的 &lt;/p&gt;&lt;p&gt;验证如下。&lt;/p&gt;&lt;p&gt;我们直接使用 pg_partman.create_parent 按月来创建分区表：&lt;/p&gt;&lt;p&gt;查看 &lt;/p&gt;&lt;p&gt;就这么简单。&lt;/p&gt;&lt;p&gt;贴一下 create_parent 的完整签名备忘。&lt;/p&gt;&lt;p&gt;使用 &lt;/p&gt;&lt;p&gt;可以手动针对 dbo.test3 进行维护：&lt;/p&gt;&lt;p&gt;上面是我们在某个数据库下，手动指定某一张表，因此传入了表名作为参数；自动维护时，我们可以调用使用默认参数（&lt;/p&gt;&lt;p&gt;我们只需编写一个小程序，在连接字符串内拼接好指定的数据库名字，调用即可；大概如下。&lt;/p&gt;&lt;p&gt;维护分区，不但包含新建分区，也包含丢弃分区。&lt;/p&gt;&lt;p&gt;如何丢弃分区？&lt;/p&gt;&lt;p&gt;对于本文中基于时间（&lt;/p&gt;&lt;p&gt;本文介绍了 pg_partman 这个工具的构建、安装和使用。&lt;/p&gt;
                ]]>
        </content>
        </entry>

        <entry>
                <title>手动管理 PostgreSQL 数据库的分区表（一）</title>
                <link href="http://blog.linuxsand.info/partitions-manual-management-1-in-postgresql.html" />
                <id>http://blog.linuxsand.info/partitions-manual-management-1-in-postgresql.html</id>
                <updated>2019-11-25T22:22:22Z</updated>
                <content type="html">
                <![CDATA[
&lt;p&gt;RevA 版本的规格如下：&lt;/p&gt;&lt;p&gt;使用场景：&lt;/p&gt;&lt;p&gt;RevA 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;TODO 项：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;RevB 与 RevA 版本的规格区别：&lt;/p&gt;&lt;p&gt;RevB 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;这个版本开始，命名方式使用 &lt;/p&gt;&lt;p&gt;这个版本是打样迭代版本，主要规格：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;（为何直接从 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;上位机软件支持本页面所有列出的型号；它分为两个部分，一是“开箱即用”的实用工具（Utility），连接信号板后，能够快速刷新信号状态和强制数字信号输出（可批量连续测试输出通道）；
二为开发包（SDK），目前支持 &lt;/p&gt;&lt;p&gt;请到产品支持页 &lt;/p&gt;&lt;p&gt;将和我的朋友“涛哥工业科技（TaoRobotics）”联合量产，敬请期待。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;第一，用户在创建原生分区表时需用 &lt;/p&gt;&lt;p&gt;第二，手动创建子表和索引&lt;/p&gt;&lt;p&gt;我们在 psql 内查看父表和子表。（为了照顾页面宽度，删除了表格的部分栏位）&lt;/p&gt;&lt;p&gt;到这里就完成了。这是原生的分区表，不像上一篇用继承实现的分区表需要编写 function 和 trigger 来做父表到子表的重定向。&lt;/p&gt;&lt;p&gt;我们插入 32 条测试数据试一下。PG 返回 &lt;/p&gt;&lt;p&gt;再看看两张子表的行数量。分别为 22 行和 10 行，说明数据正确地写入了相应的子表。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。我们在原生分区表中手动新增子表是相对很方便了，因此只需在操作系统或者应用软件层面执行定时任务：在特定时机“拼接”出下面的 SQL 执行即可。&lt;/p&gt;&lt;p&gt;下面的代码用于移除子表。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了声明式分区（原生分区表）的基本操作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;前两篇文章（&lt;/p&gt;&lt;p&gt;本文记录了使用 &lt;/p&gt;&lt;p&gt;对于 Windows 用户，需要自己克隆代码（&lt;/p&gt;&lt;p&gt;构建后，预期得到的文件有：&lt;/p&gt;&lt;p&gt;但是阅读 &lt;/p&gt;&lt;p&gt;通过搜索 github issues，找到了&lt;/p&gt;&lt;p&gt;直接在 git bash 内执行 &lt;/p&gt;&lt;p&gt;把上一步得到的 &lt;/p&gt;&lt;p&gt;验证如下。&lt;/p&gt;&lt;p&gt;我们直接使用 pg_partman.create_parent 按月来创建分区表：&lt;/p&gt;&lt;p&gt;查看 &lt;/p&gt;&lt;p&gt;就这么简单。&lt;/p&gt;&lt;p&gt;贴一下 create_parent 的完整签名备忘。&lt;/p&gt;&lt;p&gt;使用 &lt;/p&gt;&lt;p&gt;可以手动针对 dbo.test3 进行维护：&lt;/p&gt;&lt;p&gt;上面是我们在某个数据库下，手动指定某一张表，因此传入了表名作为参数；自动维护时，我们可以调用使用默认参数（&lt;/p&gt;&lt;p&gt;我们只需编写一个小程序，在连接字符串内拼接好指定的数据库名字，调用即可；大概如下。&lt;/p&gt;&lt;p&gt;维护分区，不但包含新建分区，也包含丢弃分区。&lt;/p&gt;&lt;p&gt;如何丢弃分区？&lt;/p&gt;&lt;p&gt;对于本文中基于时间（&lt;/p&gt;&lt;p&gt;本文介绍了 pg_partman 这个工具的构建、安装和使用。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近工作之余，我在学习 PostgreSQL 的分区表。&lt;/p&gt;&lt;p&gt;被分区的表叫做 partitioned table，下文用“父表”这个词；分出的若干个表叫做 partitions，下文用“子表”这个词。&lt;/p&gt;&lt;p&gt;我在 Windows 10 上使用 PostgreSQL 14（以下简称 PG），从&lt;/p&gt;&lt;p&gt;假定有父表叫做 &lt;/p&gt;&lt;p&gt;第一，用户通过 &lt;/p&gt;&lt;p&gt;第二，编写 function 来实现父表到子表的重定向。&lt;/p&gt;&lt;p&gt;第三，编写 trigger 使得插入新行之前、执行刚刚编写好的 function：&lt;/p&gt;&lt;p&gt;到这里，我们向父表插入数据后，会发现数据实际存储在某个子表中。同时，对父表执行 &lt;/p&gt;&lt;p&gt;使用 ORM 框架的开发者需要注意，我们向父表插入 1 行数据， ORM 框架预期的返回是 &lt;/p&gt;&lt;p&gt;我们可通过修改原 function、增加新的 function 和 trigger 作为应变方法 &lt;/p&gt;&lt;p&gt;新增 function 和 trigger，用于插入后的动作。&lt;/p&gt;&lt;p&gt;这样 ORM 框架就不会抱怨了。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。随着时间的推移，如何自动创建新的分区呢？&lt;/p&gt;&lt;p&gt;我个人比较偏向于：&lt;/p&gt;&lt;p&gt;除了新增分区，维护往往也需要删除过时数据。这个很方便：&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了继承式分区的基本操作、应用此方式时需为 ORM 框架做的额外工作、分区维护和优缺点。&lt;/p&gt;
                ]]>
        </content>
        </entry>

        <entry>
                <title>对数据库和O/RM框架的流水式小结</title>
                <link href="http://blog.linuxsand.info/notes-on-databases-and-orms.html" />
                <id>http://blog.linuxsand.info/notes-on-databases-and-orms.html</id>
                <updated>2019-11-25T22:22:22Z</updated>
                <content type="html">
                <![CDATA[
&lt;p&gt;使用场景：&lt;/p&gt;&lt;p&gt;RevA 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;TODO 项：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;RevB 与 RevA 版本的规格区别：&lt;/p&gt;&lt;p&gt;RevB 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;这个版本开始，命名方式使用 &lt;/p&gt;&lt;p&gt;这个版本是打样迭代版本，主要规格：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;（为何直接从 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;上位机软件支持本页面所有列出的型号；它分为两个部分，一是“开箱即用”的实用工具（Utility），连接信号板后，能够快速刷新信号状态和强制数字信号输出（可批量连续测试输出通道）；
二为开发包（SDK），目前支持 &lt;/p&gt;&lt;p&gt;请到产品支持页 &lt;/p&gt;&lt;p&gt;将和我的朋友“涛哥工业科技（TaoRobotics）”联合量产，敬请期待。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;第一，用户在创建原生分区表时需用 &lt;/p&gt;&lt;p&gt;第二，手动创建子表和索引&lt;/p&gt;&lt;p&gt;我们在 psql 内查看父表和子表。（为了照顾页面宽度，删除了表格的部分栏位）&lt;/p&gt;&lt;p&gt;到这里就完成了。这是原生的分区表，不像上一篇用继承实现的分区表需要编写 function 和 trigger 来做父表到子表的重定向。&lt;/p&gt;&lt;p&gt;我们插入 32 条测试数据试一下。PG 返回 &lt;/p&gt;&lt;p&gt;再看看两张子表的行数量。分别为 22 行和 10 行，说明数据正确地写入了相应的子表。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。我们在原生分区表中手动新增子表是相对很方便了，因此只需在操作系统或者应用软件层面执行定时任务：在特定时机“拼接”出下面的 SQL 执行即可。&lt;/p&gt;&lt;p&gt;下面的代码用于移除子表。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了声明式分区（原生分区表）的基本操作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;前两篇文章（&lt;/p&gt;&lt;p&gt;本文记录了使用 &lt;/p&gt;&lt;p&gt;对于 Windows 用户，需要自己克隆代码（&lt;/p&gt;&lt;p&gt;构建后，预期得到的文件有：&lt;/p&gt;&lt;p&gt;但是阅读 &lt;/p&gt;&lt;p&gt;通过搜索 github issues，找到了&lt;/p&gt;&lt;p&gt;直接在 git bash 内执行 &lt;/p&gt;&lt;p&gt;把上一步得到的 &lt;/p&gt;&lt;p&gt;验证如下。&lt;/p&gt;&lt;p&gt;我们直接使用 pg_partman.create_parent 按月来创建分区表：&lt;/p&gt;&lt;p&gt;查看 &lt;/p&gt;&lt;p&gt;就这么简单。&lt;/p&gt;&lt;p&gt;贴一下 create_parent 的完整签名备忘。&lt;/p&gt;&lt;p&gt;使用 &lt;/p&gt;&lt;p&gt;可以手动针对 dbo.test3 进行维护：&lt;/p&gt;&lt;p&gt;上面是我们在某个数据库下，手动指定某一张表，因此传入了表名作为参数；自动维护时，我们可以调用使用默认参数（&lt;/p&gt;&lt;p&gt;我们只需编写一个小程序，在连接字符串内拼接好指定的数据库名字，调用即可；大概如下。&lt;/p&gt;&lt;p&gt;维护分区，不但包含新建分区，也包含丢弃分区。&lt;/p&gt;&lt;p&gt;如何丢弃分区？&lt;/p&gt;&lt;p&gt;对于本文中基于时间（&lt;/p&gt;&lt;p&gt;本文介绍了 pg_partman 这个工具的构建、安装和使用。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近工作之余，我在学习 PostgreSQL 的分区表。&lt;/p&gt;&lt;p&gt;被分区的表叫做 partitioned table，下文用“父表”这个词；分出的若干个表叫做 partitions，下文用“子表”这个词。&lt;/p&gt;&lt;p&gt;我在 Windows 10 上使用 PostgreSQL 14（以下简称 PG），从&lt;/p&gt;&lt;p&gt;假定有父表叫做 &lt;/p&gt;&lt;p&gt;第一，用户通过 &lt;/p&gt;&lt;p&gt;第二，编写 function 来实现父表到子表的重定向。&lt;/p&gt;&lt;p&gt;第三，编写 trigger 使得插入新行之前、执行刚刚编写好的 function：&lt;/p&gt;&lt;p&gt;到这里，我们向父表插入数据后，会发现数据实际存储在某个子表中。同时，对父表执行 &lt;/p&gt;&lt;p&gt;使用 ORM 框架的开发者需要注意，我们向父表插入 1 行数据， ORM 框架预期的返回是 &lt;/p&gt;&lt;p&gt;我们可通过修改原 function、增加新的 function 和 trigger 作为应变方法 &lt;/p&gt;&lt;p&gt;新增 function 和 trigger，用于插入后的动作。&lt;/p&gt;&lt;p&gt;这样 ORM 框架就不会抱怨了。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。随着时间的推移，如何自动创建新的分区呢？&lt;/p&gt;&lt;p&gt;我个人比较偏向于：&lt;/p&gt;&lt;p&gt;除了新增分区，维护往往也需要删除过时数据。这个很方便：&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了继承式分区的基本操作、应用此方式时需为 ORM 框架做的额外工作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;我的场景是客户端/服务器（C/S）版桌面工控软件（.NET），有两类数据库使用工况：&lt;/p&gt;&lt;p&gt;第一种工况下我使用 SQLite 嵌入式数据库，用 Dapper 微框架作为 O/RM（对象-关系映射）来操作数据库。第二种工况下我使用 SQL Server 2019 Express 或 PostgreSQL 作为数据库，使用 Entity Framework 6（以下简称 EF6）作为 O/RM 框架。&lt;/p&gt;&lt;p&gt;在快速批量部署时，SQLite 无需安装配置的特性是很吸引人的。我不想每台机器部署时，都要拷贝大体积的数据库软件安装包，执行安装、配置等操作，这对于现场实施人员来说是不友好的，也是有错误操作风险的。因此在能够只用 SQLite 的场合，我尽可能会用它。&lt;/p&gt;&lt;p&gt;安装软件包后，是直接通过 ADO.NET provider 来操作数据库，比较冗长。&lt;/p&gt;&lt;p&gt;而使用 Dapper &lt;/p&gt;&lt;p&gt;Dapper 的性能是很好的，它是由 Stack Overflow 的工程师们发起的开源项目，用于 Stack Overflow 的生产环境中。&lt;/p&gt;&lt;p&gt;当遇到需要存储大量数据，并且表结构经常要变化的项目时，我选用 SQL Server 2019 Express 和 Entity Framework 的搭配。先说 Entity Framework &lt;/p&gt;&lt;p&gt;EF 解放了手写 SQL、手工管理数据库连接的工作，大大提高了开发效率，程序员可以直接用 &lt;/p&gt;&lt;p&gt;很多人说 EF6 性能不行，但是对我来说足够了。几个小贴士可以显著提升性能：&lt;/p&gt;&lt;p&gt;另一个我喜欢的功能是自动迁移（Auto Migration）。当模型发生变化时，例如增加数据表栏位（column）时，在控制台执行 &lt;/p&gt;&lt;p&gt;说完了 EF，再说回 SQL Server。我对 SQL Server 没有任何抱怨。&lt;/p&gt;&lt;p&gt;不过由于我使用了免费版本（2019 Express），它的限制之一是数据库文件的&lt;/p&gt;&lt;p&gt;我选择的替代是 PostgreSQL &lt;/p&gt;&lt;p&gt;.NET 下使用 PG 往往用到如下这几个包。&lt;/p&gt;&lt;p&gt;使用 EF 操作 PG 也不是没有坑，&lt;/p&gt;
                ]]>
        </content>
        </entry>

        <entry>
                <title>Codesys 作为 Profinet 控制器操作 Beckhoff BK9053</title>
                <link href="http://blog.linuxsand.info/codesys-control-on-raspberry-pi-act-as-profinet-controller-with-beckhoff-bk9053.html" />
                <id>http://blog.linuxsand.info/codesys-control-on-raspberry-pi-act-as-profinet-controller-with-beckhoff-bk9053.html</id>
                <updated>2019-11-25T22:22:22Z</updated>
                <content type="html">
                <![CDATA[
&lt;p&gt;RevA 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;TODO 项：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;RevB 与 RevA 版本的规格区别：&lt;/p&gt;&lt;p&gt;RevB 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;这个版本开始，命名方式使用 &lt;/p&gt;&lt;p&gt;这个版本是打样迭代版本，主要规格：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;（为何直接从 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;上位机软件支持本页面所有列出的型号；它分为两个部分，一是“开箱即用”的实用工具（Utility），连接信号板后，能够快速刷新信号状态和强制数字信号输出（可批量连续测试输出通道）；
二为开发包（SDK），目前支持 &lt;/p&gt;&lt;p&gt;请到产品支持页 &lt;/p&gt;&lt;p&gt;将和我的朋友“涛哥工业科技（TaoRobotics）”联合量产，敬请期待。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;第一，用户在创建原生分区表时需用 &lt;/p&gt;&lt;p&gt;第二，手动创建子表和索引&lt;/p&gt;&lt;p&gt;我们在 psql 内查看父表和子表。（为了照顾页面宽度，删除了表格的部分栏位）&lt;/p&gt;&lt;p&gt;到这里就完成了。这是原生的分区表，不像上一篇用继承实现的分区表需要编写 function 和 trigger 来做父表到子表的重定向。&lt;/p&gt;&lt;p&gt;我们插入 32 条测试数据试一下。PG 返回 &lt;/p&gt;&lt;p&gt;再看看两张子表的行数量。分别为 22 行和 10 行，说明数据正确地写入了相应的子表。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。我们在原生分区表中手动新增子表是相对很方便了，因此只需在操作系统或者应用软件层面执行定时任务：在特定时机“拼接”出下面的 SQL 执行即可。&lt;/p&gt;&lt;p&gt;下面的代码用于移除子表。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了声明式分区（原生分区表）的基本操作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;前两篇文章（&lt;/p&gt;&lt;p&gt;本文记录了使用 &lt;/p&gt;&lt;p&gt;对于 Windows 用户，需要自己克隆代码（&lt;/p&gt;&lt;p&gt;构建后，预期得到的文件有：&lt;/p&gt;&lt;p&gt;但是阅读 &lt;/p&gt;&lt;p&gt;通过搜索 github issues，找到了&lt;/p&gt;&lt;p&gt;直接在 git bash 内执行 &lt;/p&gt;&lt;p&gt;把上一步得到的 &lt;/p&gt;&lt;p&gt;验证如下。&lt;/p&gt;&lt;p&gt;我们直接使用 pg_partman.create_parent 按月来创建分区表：&lt;/p&gt;&lt;p&gt;查看 &lt;/p&gt;&lt;p&gt;就这么简单。&lt;/p&gt;&lt;p&gt;贴一下 create_parent 的完整签名备忘。&lt;/p&gt;&lt;p&gt;使用 &lt;/p&gt;&lt;p&gt;可以手动针对 dbo.test3 进行维护：&lt;/p&gt;&lt;p&gt;上面是我们在某个数据库下，手动指定某一张表，因此传入了表名作为参数；自动维护时，我们可以调用使用默认参数（&lt;/p&gt;&lt;p&gt;我们只需编写一个小程序，在连接字符串内拼接好指定的数据库名字，调用即可；大概如下。&lt;/p&gt;&lt;p&gt;维护分区，不但包含新建分区，也包含丢弃分区。&lt;/p&gt;&lt;p&gt;如何丢弃分区？&lt;/p&gt;&lt;p&gt;对于本文中基于时间（&lt;/p&gt;&lt;p&gt;本文介绍了 pg_partman 这个工具的构建、安装和使用。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近工作之余，我在学习 PostgreSQL 的分区表。&lt;/p&gt;&lt;p&gt;被分区的表叫做 partitioned table，下文用“父表”这个词；分出的若干个表叫做 partitions，下文用“子表”这个词。&lt;/p&gt;&lt;p&gt;我在 Windows 10 上使用 PostgreSQL 14（以下简称 PG），从&lt;/p&gt;&lt;p&gt;假定有父表叫做 &lt;/p&gt;&lt;p&gt;第一，用户通过 &lt;/p&gt;&lt;p&gt;第二，编写 function 来实现父表到子表的重定向。&lt;/p&gt;&lt;p&gt;第三，编写 trigger 使得插入新行之前、执行刚刚编写好的 function：&lt;/p&gt;&lt;p&gt;到这里，我们向父表插入数据后，会发现数据实际存储在某个子表中。同时，对父表执行 &lt;/p&gt;&lt;p&gt;使用 ORM 框架的开发者需要注意，我们向父表插入 1 行数据， ORM 框架预期的返回是 &lt;/p&gt;&lt;p&gt;我们可通过修改原 function、增加新的 function 和 trigger 作为应变方法 &lt;/p&gt;&lt;p&gt;新增 function 和 trigger，用于插入后的动作。&lt;/p&gt;&lt;p&gt;这样 ORM 框架就不会抱怨了。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。随着时间的推移，如何自动创建新的分区呢？&lt;/p&gt;&lt;p&gt;我个人比较偏向于：&lt;/p&gt;&lt;p&gt;除了新增分区，维护往往也需要删除过时数据。这个很方便：&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了继承式分区的基本操作、应用此方式时需为 ORM 框架做的额外工作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;我的场景是客户端/服务器（C/S）版桌面工控软件（.NET），有两类数据库使用工况：&lt;/p&gt;&lt;p&gt;第一种工况下我使用 SQLite 嵌入式数据库，用 Dapper 微框架作为 O/RM（对象-关系映射）来操作数据库。第二种工况下我使用 SQL Server 2019 Express 或 PostgreSQL 作为数据库，使用 Entity Framework 6（以下简称 EF6）作为 O/RM 框架。&lt;/p&gt;&lt;p&gt;在快速批量部署时，SQLite 无需安装配置的特性是很吸引人的。我不想每台机器部署时，都要拷贝大体积的数据库软件安装包，执行安装、配置等操作，这对于现场实施人员来说是不友好的，也是有错误操作风险的。因此在能够只用 SQLite 的场合，我尽可能会用它。&lt;/p&gt;&lt;p&gt;安装软件包后，是直接通过 ADO.NET provider 来操作数据库，比较冗长。&lt;/p&gt;&lt;p&gt;而使用 Dapper &lt;/p&gt;&lt;p&gt;Dapper 的性能是很好的，它是由 Stack Overflow 的工程师们发起的开源项目，用于 Stack Overflow 的生产环境中。&lt;/p&gt;&lt;p&gt;当遇到需要存储大量数据，并且表结构经常要变化的项目时，我选用 SQL Server 2019 Express 和 Entity Framework 的搭配。先说 Entity Framework &lt;/p&gt;&lt;p&gt;EF 解放了手写 SQL、手工管理数据库连接的工作，大大提高了开发效率，程序员可以直接用 &lt;/p&gt;&lt;p&gt;很多人说 EF6 性能不行，但是对我来说足够了。几个小贴士可以显著提升性能：&lt;/p&gt;&lt;p&gt;另一个我喜欢的功能是自动迁移（Auto Migration）。当模型发生变化时，例如增加数据表栏位（column）时，在控制台执行 &lt;/p&gt;&lt;p&gt;说完了 EF，再说回 SQL Server。我对 SQL Server 没有任何抱怨。&lt;/p&gt;&lt;p&gt;不过由于我使用了免费版本（2019 Express），它的限制之一是数据库文件的&lt;/p&gt;&lt;p&gt;我选择的替代是 PostgreSQL &lt;/p&gt;&lt;p&gt;.NET 下使用 PG 往往用到如下这几个包。&lt;/p&gt;&lt;p&gt;使用 EF 操作 PG 也不是没有坑，&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近我从 Codesys 中国购买了学习套件：树莓派4B、Codesys 许可证和《开放式控制系统编程技术》这本书。&lt;/p&gt;&lt;p&gt;五一假期试玩了一把。以下凭借记忆叙述大致步骤，作为备忘，也希望帮助从搜索引擎过来的朋友。&lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;树莓派的相关操作，例如配置 ssh / vnc server、配置网络接口 eth0 等操作不在此赘述，可参考 &lt;/p&gt;&lt;p&gt;大致步骤：&lt;/p&gt;&lt;p&gt;完成授权后启动 runtime，尝试新建工程并下载，确保正常工作，至此树莓派变身为一台软 PLC。&lt;/p&gt;&lt;p&gt;使用网络交换机将设备连接到一起，我的设备情况如下。&lt;/p&gt;&lt;p&gt;注意：我遇到了树莓派的 eth0 无法 ping 通外部设备的情况。搜索后执行了 &lt;/p&gt;&lt;p&gt;下载、安装设备的 GSD 文件操作，这里也不提。&lt;/p&gt;&lt;p&gt;关键步骤：&lt;/p&gt;&lt;p&gt;硬件组态完成后，进行 I/O 映射。&lt;/p&gt;&lt;p&gt;我使用的硬件：BK9053 耦合器 &lt;/p&gt;&lt;p&gt;完成映射后发现无法手动强制信号……最后发现用代码置位信号后，可以手动强制了，不解。&lt;/p&gt;&lt;p&gt;最后录制了一个“跑马灯”效果的 demo：循环点亮每个数字输出通道。&lt;/p&gt;&lt;p&gt;https://v.youku.com/v_show/id_XNDY2MzY4MjAzMg==.html&lt;/p&gt;
                ]]>
        </content>
        </entry>

        <entry>
                <title>使用 FANUC Roboguide 进行拆垛应用仿真</title>
                <link href="http://blog.linuxsand.info/robot-depalletizing-demo-in-fanuc-roboguide.html" />
                <id>http://blog.linuxsand.info/robot-depalletizing-demo-in-fanuc-roboguide.html</id>
                <updated>2019-11-25T22:22:22Z</updated>
                <content type="html">
                <![CDATA[
&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;TODO 项：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;RevB 与 RevA 版本的规格区别：&lt;/p&gt;&lt;p&gt;RevB 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;这个版本开始，命名方式使用 &lt;/p&gt;&lt;p&gt;这个版本是打样迭代版本，主要规格：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;（为何直接从 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;上位机软件支持本页面所有列出的型号；它分为两个部分，一是“开箱即用”的实用工具（Utility），连接信号板后，能够快速刷新信号状态和强制数字信号输出（可批量连续测试输出通道）；
二为开发包（SDK），目前支持 &lt;/p&gt;&lt;p&gt;请到产品支持页 &lt;/p&gt;&lt;p&gt;将和我的朋友“涛哥工业科技（TaoRobotics）”联合量产，敬请期待。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;第一，用户在创建原生分区表时需用 &lt;/p&gt;&lt;p&gt;第二，手动创建子表和索引&lt;/p&gt;&lt;p&gt;我们在 psql 内查看父表和子表。（为了照顾页面宽度，删除了表格的部分栏位）&lt;/p&gt;&lt;p&gt;到这里就完成了。这是原生的分区表，不像上一篇用继承实现的分区表需要编写 function 和 trigger 来做父表到子表的重定向。&lt;/p&gt;&lt;p&gt;我们插入 32 条测试数据试一下。PG 返回 &lt;/p&gt;&lt;p&gt;再看看两张子表的行数量。分别为 22 行和 10 行，说明数据正确地写入了相应的子表。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。我们在原生分区表中手动新增子表是相对很方便了，因此只需在操作系统或者应用软件层面执行定时任务：在特定时机“拼接”出下面的 SQL 执行即可。&lt;/p&gt;&lt;p&gt;下面的代码用于移除子表。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了声明式分区（原生分区表）的基本操作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;前两篇文章（&lt;/p&gt;&lt;p&gt;本文记录了使用 &lt;/p&gt;&lt;p&gt;对于 Windows 用户，需要自己克隆代码（&lt;/p&gt;&lt;p&gt;构建后，预期得到的文件有：&lt;/p&gt;&lt;p&gt;但是阅读 &lt;/p&gt;&lt;p&gt;通过搜索 github issues，找到了&lt;/p&gt;&lt;p&gt;直接在 git bash 内执行 &lt;/p&gt;&lt;p&gt;把上一步得到的 &lt;/p&gt;&lt;p&gt;验证如下。&lt;/p&gt;&lt;p&gt;我们直接使用 pg_partman.create_parent 按月来创建分区表：&lt;/p&gt;&lt;p&gt;查看 &lt;/p&gt;&lt;p&gt;就这么简单。&lt;/p&gt;&lt;p&gt;贴一下 create_parent 的完整签名备忘。&lt;/p&gt;&lt;p&gt;使用 &lt;/p&gt;&lt;p&gt;可以手动针对 dbo.test3 进行维护：&lt;/p&gt;&lt;p&gt;上面是我们在某个数据库下，手动指定某一张表，因此传入了表名作为参数；自动维护时，我们可以调用使用默认参数（&lt;/p&gt;&lt;p&gt;我们只需编写一个小程序，在连接字符串内拼接好指定的数据库名字，调用即可；大概如下。&lt;/p&gt;&lt;p&gt;维护分区，不但包含新建分区，也包含丢弃分区。&lt;/p&gt;&lt;p&gt;如何丢弃分区？&lt;/p&gt;&lt;p&gt;对于本文中基于时间（&lt;/p&gt;&lt;p&gt;本文介绍了 pg_partman 这个工具的构建、安装和使用。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近工作之余，我在学习 PostgreSQL 的分区表。&lt;/p&gt;&lt;p&gt;被分区的表叫做 partitioned table，下文用“父表”这个词；分出的若干个表叫做 partitions，下文用“子表”这个词。&lt;/p&gt;&lt;p&gt;我在 Windows 10 上使用 PostgreSQL 14（以下简称 PG），从&lt;/p&gt;&lt;p&gt;假定有父表叫做 &lt;/p&gt;&lt;p&gt;第一，用户通过 &lt;/p&gt;&lt;p&gt;第二，编写 function 来实现父表到子表的重定向。&lt;/p&gt;&lt;p&gt;第三，编写 trigger 使得插入新行之前、执行刚刚编写好的 function：&lt;/p&gt;&lt;p&gt;到这里，我们向父表插入数据后，会发现数据实际存储在某个子表中。同时，对父表执行 &lt;/p&gt;&lt;p&gt;使用 ORM 框架的开发者需要注意，我们向父表插入 1 行数据， ORM 框架预期的返回是 &lt;/p&gt;&lt;p&gt;我们可通过修改原 function、增加新的 function 和 trigger 作为应变方法 &lt;/p&gt;&lt;p&gt;新增 function 和 trigger，用于插入后的动作。&lt;/p&gt;&lt;p&gt;这样 ORM 框架就不会抱怨了。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。随着时间的推移，如何自动创建新的分区呢？&lt;/p&gt;&lt;p&gt;我个人比较偏向于：&lt;/p&gt;&lt;p&gt;除了新增分区，维护往往也需要删除过时数据。这个很方便：&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了继承式分区的基本操作、应用此方式时需为 ORM 框架做的额外工作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;我的场景是客户端/服务器（C/S）版桌面工控软件（.NET），有两类数据库使用工况：&lt;/p&gt;&lt;p&gt;第一种工况下我使用 SQLite 嵌入式数据库，用 Dapper 微框架作为 O/RM（对象-关系映射）来操作数据库。第二种工况下我使用 SQL Server 2019 Express 或 PostgreSQL 作为数据库，使用 Entity Framework 6（以下简称 EF6）作为 O/RM 框架。&lt;/p&gt;&lt;p&gt;在快速批量部署时，SQLite 无需安装配置的特性是很吸引人的。我不想每台机器部署时，都要拷贝大体积的数据库软件安装包，执行安装、配置等操作，这对于现场实施人员来说是不友好的，也是有错误操作风险的。因此在能够只用 SQLite 的场合，我尽可能会用它。&lt;/p&gt;&lt;p&gt;安装软件包后，是直接通过 ADO.NET provider 来操作数据库，比较冗长。&lt;/p&gt;&lt;p&gt;而使用 Dapper &lt;/p&gt;&lt;p&gt;Dapper 的性能是很好的，它是由 Stack Overflow 的工程师们发起的开源项目，用于 Stack Overflow 的生产环境中。&lt;/p&gt;&lt;p&gt;当遇到需要存储大量数据，并且表结构经常要变化的项目时，我选用 SQL Server 2019 Express 和 Entity Framework 的搭配。先说 Entity Framework &lt;/p&gt;&lt;p&gt;EF 解放了手写 SQL、手工管理数据库连接的工作，大大提高了开发效率，程序员可以直接用 &lt;/p&gt;&lt;p&gt;很多人说 EF6 性能不行，但是对我来说足够了。几个小贴士可以显著提升性能：&lt;/p&gt;&lt;p&gt;另一个我喜欢的功能是自动迁移（Auto Migration）。当模型发生变化时，例如增加数据表栏位（column）时，在控制台执行 &lt;/p&gt;&lt;p&gt;说完了 EF，再说回 SQL Server。我对 SQL Server 没有任何抱怨。&lt;/p&gt;&lt;p&gt;不过由于我使用了免费版本（2019 Express），它的限制之一是数据库文件的&lt;/p&gt;&lt;p&gt;我选择的替代是 PostgreSQL &lt;/p&gt;&lt;p&gt;.NET 下使用 PG 往往用到如下这几个包。&lt;/p&gt;&lt;p&gt;使用 EF 操作 PG 也不是没有坑，&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近我从 Codesys 中国购买了学习套件：树莓派4B、Codesys 许可证和《开放式控制系统编程技术》这本书。&lt;/p&gt;&lt;p&gt;五一假期试玩了一把。以下凭借记忆叙述大致步骤，作为备忘，也希望帮助从搜索引擎过来的朋友。&lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;树莓派的相关操作，例如配置 ssh / vnc server、配置网络接口 eth0 等操作不在此赘述，可参考 &lt;/p&gt;&lt;p&gt;大致步骤：&lt;/p&gt;&lt;p&gt;完成授权后启动 runtime，尝试新建工程并下载，确保正常工作，至此树莓派变身为一台软 PLC。&lt;/p&gt;&lt;p&gt;使用网络交换机将设备连接到一起，我的设备情况如下。&lt;/p&gt;&lt;p&gt;注意：我遇到了树莓派的 eth0 无法 ping 通外部设备的情况。搜索后执行了 &lt;/p&gt;&lt;p&gt;下载、安装设备的 GSD 文件操作，这里也不提。&lt;/p&gt;&lt;p&gt;关键步骤：&lt;/p&gt;&lt;p&gt;硬件组态完成后，进行 I/O 映射。&lt;/p&gt;&lt;p&gt;我使用的硬件：BK9053 耦合器 &lt;/p&gt;&lt;p&gt;完成映射后发现无法手动强制信号……最后发现用代码置位信号后，可以手动强制了，不解。&lt;/p&gt;&lt;p&gt;最后录制了一个“跑马灯”效果的 demo：循环点亮每个数字输出通道。&lt;/p&gt;&lt;p&gt;https://v.youku.com/v_show/id_XNDY2MzY4MjAzMg==.html&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近公司让我紧急做个 FANUC 机器人的拆垛仿真，需要：&lt;/p&gt;&lt;p&gt;前者这条约束，导致没法用 RoboDK 这样的第三方软件。&lt;/p&gt;&lt;p&gt;于是不得不用 FANUC 的 Roboguide 了，虽然我接触 FANUC 好些年了，但只用 Roboguide 做程序代码的仿真和基本的布局验证。&lt;/p&gt;&lt;p&gt;好一顿折腾，记录如下。&lt;/p&gt;&lt;p&gt;我会从本次任务中抽取几个主题，构成本文内容：&lt;/p&gt;&lt;p&gt;除去机器人模型外，需要若干基本模型，用于支持仿真。例如，搬运对象：箱子（立方体）；托盘；机器人工具（吸盘）。&lt;/p&gt;&lt;p&gt;可以通过文件来导入，也可以在 Roboguide 内进行简单几何体的建模。模型导入或创建完毕后，依据布局图进行相应的模型摆放。&lt;/p&gt;&lt;p&gt;如何安装机器人工具这类操作，不在此赘述，请查找自带的帮助文档，或者按照你习惯的操作进行探索。&lt;/p&gt;&lt;p&gt;Roboguide 给框定的操作逻辑是，用户先想好导入的模型是什么类别（machine / fixture / part / obstacle），然后再导入。&lt;/p&gt;&lt;p&gt;摘录自帮助文档的《Working with Parts》章节：&lt;/p&gt;&lt;p&gt;例如，已经导入了类别为 Part 的模型，但是它不能直接使用；用户需要将它与夹具或机器人工具关联。&lt;/p&gt;&lt;p&gt;下表为手工生成垛型的操作。&lt;/p&gt;&lt;p&gt;为了实现仿真抓放，我们先配置机器人工具以实现抓取、放置的动画效果，下表的操作将机器人工具（EOAT）与 parts 关联。&lt;/p&gt;&lt;p&gt;将机器人工具与 part 关联后，如何实现 attach / detach 呢？Roboguide 提供了一种特别类型的程序，叫做仿真程序（Simulation program）；它与真实的机器人程序（TPE / KAREL 程序）不同，只能用于仿真环境。&lt;/p&gt;&lt;p&gt;从 Teach 菜单添加仿真程序，例如 &lt;/p&gt;&lt;p&gt;同理，可以添加放置的程序（使用 &lt;/p&gt;&lt;p&gt;终于到了综合部分：如何让机器人运动到某个位姿，抓取箱子，运动到另一个位姿，放置箱子。&lt;/p&gt;&lt;p&gt;如果抓取位姿、放置位姿都是固定的，那么很简单：添加仿真程序，插入类似 &lt;/p&gt;&lt;p&gt;但是本任务的特点是：&lt;/p&gt;&lt;p&gt;好，这“一推一拉”的形势，决定了我们肯定要用聪明些的方法。&lt;/p&gt;&lt;p&gt;帮助文档的《Teach a program》章含有 Combining simulation and TP programs into a single animation program 小节，完成本任务需要用到仿真程序和机器人程序的结合。因为仿真程序（Simulation program）的指令和能力非常有限。&lt;/p&gt;&lt;p&gt;我的思路为，得到箱子位姿后，设法计算、生成两个机器人程序（&lt;/p&gt;&lt;p&gt;细心的读者会发现，在仿真程序中使用了全局的数字寄存器 &lt;/p&gt;&lt;p&gt;5.3 节得到了箱子参考托盘的位姿，实际使用时应该把箱子位姿变换到机器人世界坐标系下面：托盘位姿是已知的，所以箱子的绝对位姿是可以在外部算出来的。&lt;/p&gt;&lt;p&gt;得到箱子的绝对位姿后，至少要按照箱子的 Z 值排序，以便进行从高到低的拆垛（废话）。当吸盘比箱子大时，同层的箱子也不能随便吸取，否则就露馅了；而是应当用吸盘边角去吸取。这个涉及到计算，为了减少麻烦，本次通过设置机器人工具的 part offset 来规避。&lt;/p&gt;&lt;p&gt;到这里，我们已经手握 36 个处理后（排序）的箱子位姿，就可以根据如下的 FANUC TPE 程序的模板来生成 &lt;/p&gt;&lt;p&gt;科普：TPE 程序的源文件后缀为 &lt;/p&gt;&lt;p&gt;至此，仿真程序就能调用生成的机器人程序（包含接近、吸取、离开箱子的位姿），实现精确运动到每个箱子上表面，抓取和放置了。&lt;/p&gt;
                ]]>
        </content>
        </entry>

        <entry>
                <title>cmd.exe 的快速编辑模式阻塞了应用程序</title>
                <link href="http://blog.linuxsand.info/cmd_quick_edit_mode.html" />
                <id>http://blog.linuxsand.info/cmd_quick_edit_mode.html</id>
                <updated>2019-11-25T22:22:22Z</updated>
                <content type="html">
                <![CDATA[
&lt;p&gt;TODO 项：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;RevB 与 RevA 版本的规格区别：&lt;/p&gt;&lt;p&gt;RevB 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;这个版本开始，命名方式使用 &lt;/p&gt;&lt;p&gt;这个版本是打样迭代版本，主要规格：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;（为何直接从 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;上位机软件支持本页面所有列出的型号；它分为两个部分，一是“开箱即用”的实用工具（Utility），连接信号板后，能够快速刷新信号状态和强制数字信号输出（可批量连续测试输出通道）；
二为开发包（SDK），目前支持 &lt;/p&gt;&lt;p&gt;请到产品支持页 &lt;/p&gt;&lt;p&gt;将和我的朋友“涛哥工业科技（TaoRobotics）”联合量产，敬请期待。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;第一，用户在创建原生分区表时需用 &lt;/p&gt;&lt;p&gt;第二，手动创建子表和索引&lt;/p&gt;&lt;p&gt;我们在 psql 内查看父表和子表。（为了照顾页面宽度，删除了表格的部分栏位）&lt;/p&gt;&lt;p&gt;到这里就完成了。这是原生的分区表，不像上一篇用继承实现的分区表需要编写 function 和 trigger 来做父表到子表的重定向。&lt;/p&gt;&lt;p&gt;我们插入 32 条测试数据试一下。PG 返回 &lt;/p&gt;&lt;p&gt;再看看两张子表的行数量。分别为 22 行和 10 行，说明数据正确地写入了相应的子表。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。我们在原生分区表中手动新增子表是相对很方便了，因此只需在操作系统或者应用软件层面执行定时任务：在特定时机“拼接”出下面的 SQL 执行即可。&lt;/p&gt;&lt;p&gt;下面的代码用于移除子表。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了声明式分区（原生分区表）的基本操作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;前两篇文章（&lt;/p&gt;&lt;p&gt;本文记录了使用 &lt;/p&gt;&lt;p&gt;对于 Windows 用户，需要自己克隆代码（&lt;/p&gt;&lt;p&gt;构建后，预期得到的文件有：&lt;/p&gt;&lt;p&gt;但是阅读 &lt;/p&gt;&lt;p&gt;通过搜索 github issues，找到了&lt;/p&gt;&lt;p&gt;直接在 git bash 内执行 &lt;/p&gt;&lt;p&gt;把上一步得到的 &lt;/p&gt;&lt;p&gt;验证如下。&lt;/p&gt;&lt;p&gt;我们直接使用 pg_partman.create_parent 按月来创建分区表：&lt;/p&gt;&lt;p&gt;查看 &lt;/p&gt;&lt;p&gt;就这么简单。&lt;/p&gt;&lt;p&gt;贴一下 create_parent 的完整签名备忘。&lt;/p&gt;&lt;p&gt;使用 &lt;/p&gt;&lt;p&gt;可以手动针对 dbo.test3 进行维护：&lt;/p&gt;&lt;p&gt;上面是我们在某个数据库下，手动指定某一张表，因此传入了表名作为参数；自动维护时，我们可以调用使用默认参数（&lt;/p&gt;&lt;p&gt;我们只需编写一个小程序，在连接字符串内拼接好指定的数据库名字，调用即可；大概如下。&lt;/p&gt;&lt;p&gt;维护分区，不但包含新建分区，也包含丢弃分区。&lt;/p&gt;&lt;p&gt;如何丢弃分区？&lt;/p&gt;&lt;p&gt;对于本文中基于时间（&lt;/p&gt;&lt;p&gt;本文介绍了 pg_partman 这个工具的构建、安装和使用。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近工作之余，我在学习 PostgreSQL 的分区表。&lt;/p&gt;&lt;p&gt;被分区的表叫做 partitioned table，下文用“父表”这个词；分出的若干个表叫做 partitions，下文用“子表”这个词。&lt;/p&gt;&lt;p&gt;我在 Windows 10 上使用 PostgreSQL 14（以下简称 PG），从&lt;/p&gt;&lt;p&gt;假定有父表叫做 &lt;/p&gt;&lt;p&gt;第一，用户通过 &lt;/p&gt;&lt;p&gt;第二，编写 function 来实现父表到子表的重定向。&lt;/p&gt;&lt;p&gt;第三，编写 trigger 使得插入新行之前、执行刚刚编写好的 function：&lt;/p&gt;&lt;p&gt;到这里，我们向父表插入数据后，会发现数据实际存储在某个子表中。同时，对父表执行 &lt;/p&gt;&lt;p&gt;使用 ORM 框架的开发者需要注意，我们向父表插入 1 行数据， ORM 框架预期的返回是 &lt;/p&gt;&lt;p&gt;我们可通过修改原 function、增加新的 function 和 trigger 作为应变方法 &lt;/p&gt;&lt;p&gt;新增 function 和 trigger，用于插入后的动作。&lt;/p&gt;&lt;p&gt;这样 ORM 框架就不会抱怨了。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。随着时间的推移，如何自动创建新的分区呢？&lt;/p&gt;&lt;p&gt;我个人比较偏向于：&lt;/p&gt;&lt;p&gt;除了新增分区，维护往往也需要删除过时数据。这个很方便：&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了继承式分区的基本操作、应用此方式时需为 ORM 框架做的额外工作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;我的场景是客户端/服务器（C/S）版桌面工控软件（.NET），有两类数据库使用工况：&lt;/p&gt;&lt;p&gt;第一种工况下我使用 SQLite 嵌入式数据库，用 Dapper 微框架作为 O/RM（对象-关系映射）来操作数据库。第二种工况下我使用 SQL Server 2019 Express 或 PostgreSQL 作为数据库，使用 Entity Framework 6（以下简称 EF6）作为 O/RM 框架。&lt;/p&gt;&lt;p&gt;在快速批量部署时，SQLite 无需安装配置的特性是很吸引人的。我不想每台机器部署时，都要拷贝大体积的数据库软件安装包，执行安装、配置等操作，这对于现场实施人员来说是不友好的，也是有错误操作风险的。因此在能够只用 SQLite 的场合，我尽可能会用它。&lt;/p&gt;&lt;p&gt;安装软件包后，是直接通过 ADO.NET provider 来操作数据库，比较冗长。&lt;/p&gt;&lt;p&gt;而使用 Dapper &lt;/p&gt;&lt;p&gt;Dapper 的性能是很好的，它是由 Stack Overflow 的工程师们发起的开源项目，用于 Stack Overflow 的生产环境中。&lt;/p&gt;&lt;p&gt;当遇到需要存储大量数据，并且表结构经常要变化的项目时，我选用 SQL Server 2019 Express 和 Entity Framework 的搭配。先说 Entity Framework &lt;/p&gt;&lt;p&gt;EF 解放了手写 SQL、手工管理数据库连接的工作，大大提高了开发效率，程序员可以直接用 &lt;/p&gt;&lt;p&gt;很多人说 EF6 性能不行，但是对我来说足够了。几个小贴士可以显著提升性能：&lt;/p&gt;&lt;p&gt;另一个我喜欢的功能是自动迁移（Auto Migration）。当模型发生变化时，例如增加数据表栏位（column）时，在控制台执行 &lt;/p&gt;&lt;p&gt;说完了 EF，再说回 SQL Server。我对 SQL Server 没有任何抱怨。&lt;/p&gt;&lt;p&gt;不过由于我使用了免费版本（2019 Express），它的限制之一是数据库文件的&lt;/p&gt;&lt;p&gt;我选择的替代是 PostgreSQL &lt;/p&gt;&lt;p&gt;.NET 下使用 PG 往往用到如下这几个包。&lt;/p&gt;&lt;p&gt;使用 EF 操作 PG 也不是没有坑，&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近我从 Codesys 中国购买了学习套件：树莓派4B、Codesys 许可证和《开放式控制系统编程技术》这本书。&lt;/p&gt;&lt;p&gt;五一假期试玩了一把。以下凭借记忆叙述大致步骤，作为备忘，也希望帮助从搜索引擎过来的朋友。&lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;树莓派的相关操作，例如配置 ssh / vnc server、配置网络接口 eth0 等操作不在此赘述，可参考 &lt;/p&gt;&lt;p&gt;大致步骤：&lt;/p&gt;&lt;p&gt;完成授权后启动 runtime，尝试新建工程并下载，确保正常工作，至此树莓派变身为一台软 PLC。&lt;/p&gt;&lt;p&gt;使用网络交换机将设备连接到一起，我的设备情况如下。&lt;/p&gt;&lt;p&gt;注意：我遇到了树莓派的 eth0 无法 ping 通外部设备的情况。搜索后执行了 &lt;/p&gt;&lt;p&gt;下载、安装设备的 GSD 文件操作，这里也不提。&lt;/p&gt;&lt;p&gt;关键步骤：&lt;/p&gt;&lt;p&gt;硬件组态完成后，进行 I/O 映射。&lt;/p&gt;&lt;p&gt;我使用的硬件：BK9053 耦合器 &lt;/p&gt;&lt;p&gt;完成映射后发现无法手动强制信号……最后发现用代码置位信号后，可以手动强制了，不解。&lt;/p&gt;&lt;p&gt;最后录制了一个“跑马灯”效果的 demo：循环点亮每个数字输出通道。&lt;/p&gt;&lt;p&gt;https://v.youku.com/v_show/id_XNDY2MzY4MjAzMg==.html&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近公司让我紧急做个 FANUC 机器人的拆垛仿真，需要：&lt;/p&gt;&lt;p&gt;前者这条约束，导致没法用 RoboDK 这样的第三方软件。&lt;/p&gt;&lt;p&gt;于是不得不用 FANUC 的 Roboguide 了，虽然我接触 FANUC 好些年了，但只用 Roboguide 做程序代码的仿真和基本的布局验证。&lt;/p&gt;&lt;p&gt;好一顿折腾，记录如下。&lt;/p&gt;&lt;p&gt;我会从本次任务中抽取几个主题，构成本文内容：&lt;/p&gt;&lt;p&gt;除去机器人模型外，需要若干基本模型，用于支持仿真。例如，搬运对象：箱子（立方体）；托盘；机器人工具（吸盘）。&lt;/p&gt;&lt;p&gt;可以通过文件来导入，也可以在 Roboguide 内进行简单几何体的建模。模型导入或创建完毕后，依据布局图进行相应的模型摆放。&lt;/p&gt;&lt;p&gt;如何安装机器人工具这类操作，不在此赘述，请查找自带的帮助文档，或者按照你习惯的操作进行探索。&lt;/p&gt;&lt;p&gt;Roboguide 给框定的操作逻辑是，用户先想好导入的模型是什么类别（machine / fixture / part / obstacle），然后再导入。&lt;/p&gt;&lt;p&gt;摘录自帮助文档的《Working with Parts》章节：&lt;/p&gt;&lt;p&gt;例如，已经导入了类别为 Part 的模型，但是它不能直接使用；用户需要将它与夹具或机器人工具关联。&lt;/p&gt;&lt;p&gt;下表为手工生成垛型的操作。&lt;/p&gt;&lt;p&gt;为了实现仿真抓放，我们先配置机器人工具以实现抓取、放置的动画效果，下表的操作将机器人工具（EOAT）与 parts 关联。&lt;/p&gt;&lt;p&gt;将机器人工具与 part 关联后，如何实现 attach / detach 呢？Roboguide 提供了一种特别类型的程序，叫做仿真程序（Simulation program）；它与真实的机器人程序（TPE / KAREL 程序）不同，只能用于仿真环境。&lt;/p&gt;&lt;p&gt;从 Teach 菜单添加仿真程序，例如 &lt;/p&gt;&lt;p&gt;同理，可以添加放置的程序（使用 &lt;/p&gt;&lt;p&gt;终于到了综合部分：如何让机器人运动到某个位姿，抓取箱子，运动到另一个位姿，放置箱子。&lt;/p&gt;&lt;p&gt;如果抓取位姿、放置位姿都是固定的，那么很简单：添加仿真程序，插入类似 &lt;/p&gt;&lt;p&gt;但是本任务的特点是：&lt;/p&gt;&lt;p&gt;好，这“一推一拉”的形势，决定了我们肯定要用聪明些的方法。&lt;/p&gt;&lt;p&gt;帮助文档的《Teach a program》章含有 Combining simulation and TP programs into a single animation program 小节，完成本任务需要用到仿真程序和机器人程序的结合。因为仿真程序（Simulation program）的指令和能力非常有限。&lt;/p&gt;&lt;p&gt;我的思路为，得到箱子位姿后，设法计算、生成两个机器人程序（&lt;/p&gt;&lt;p&gt;细心的读者会发现，在仿真程序中使用了全局的数字寄存器 &lt;/p&gt;&lt;p&gt;5.3 节得到了箱子参考托盘的位姿，实际使用时应该把箱子位姿变换到机器人世界坐标系下面：托盘位姿是已知的，所以箱子的绝对位姿是可以在外部算出来的。&lt;/p&gt;&lt;p&gt;得到箱子的绝对位姿后，至少要按照箱子的 Z 值排序，以便进行从高到低的拆垛（废话）。当吸盘比箱子大时，同层的箱子也不能随便吸取，否则就露馅了；而是应当用吸盘边角去吸取。这个涉及到计算，为了减少麻烦，本次通过设置机器人工具的 part offset 来规避。&lt;/p&gt;&lt;p&gt;到这里，我们已经手握 36 个处理后（排序）的箱子位姿，就可以根据如下的 FANUC TPE 程序的模板来生成 &lt;/p&gt;&lt;p&gt;科普：TPE 程序的源文件后缀为 &lt;/p&gt;&lt;p&gt;至此，仿真程序就能调用生成的机器人程序（包含接近、吸取、离开箱子的位姿），实现精确运动到每个箱子上表面，抓取和放置了。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;近期出差发生了一件很有意思的事情。&lt;/p&gt;&lt;p&gt;工控机上跑着一个命令行程序（该程序具备网络通信功能），它会频繁打印信息到标准输出。由于需要定期查看输出的最新信息，我们习惯按住鼠标左键拖选关键输出（此时进入了 cmd.exe 的快速编辑模式），这样就能高亮显示了，阅读起来轻松些。&lt;/p&gt;&lt;p&gt;看完输出后，人就走开了（此时仍然维持着快速编辑模式）。&lt;/p&gt;&lt;p&gt;不久，我们发现似乎程序在某个时间点，本该收到外部网络数据，但是迟迟收不到。纳闷。&lt;/p&gt;&lt;p&gt;于是不得不中断设备的运行，切到手动模式操作。&lt;/p&gt;&lt;p&gt;后来同事提及，他碰到过类似事情，最后发现在选中 cmd.exe 的输出时，会阻塞程序的运行。&lt;/p&gt;&lt;p&gt;我写了几行代码验证，果然如此。&lt;/p&gt;
                ]]>
        </content>
        </entry>

        <entry>
                <title>连接 KUKA OfficeLite 到 RoboDK</title>
                <link href="http://blog.linuxsand.info/connect-kuka-officelite-to-robodk.html" />
                <id>http://blog.linuxsand.info/connect-kuka-officelite-to-robodk.html</id>
                <updated>2019-11-25T22:22:22Z</updated>
                <content type="html">
                <![CDATA[
&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;RevB 与 RevA 版本的规格区别：&lt;/p&gt;&lt;p&gt;RevB 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;这个版本开始，命名方式使用 &lt;/p&gt;&lt;p&gt;这个版本是打样迭代版本，主要规格：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;（为何直接从 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;上位机软件支持本页面所有列出的型号；它分为两个部分，一是“开箱即用”的实用工具（Utility），连接信号板后，能够快速刷新信号状态和强制数字信号输出（可批量连续测试输出通道）；
二为开发包（SDK），目前支持 &lt;/p&gt;&lt;p&gt;请到产品支持页 &lt;/p&gt;&lt;p&gt;将和我的朋友“涛哥工业科技（TaoRobotics）”联合量产，敬请期待。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;第一，用户在创建原生分区表时需用 &lt;/p&gt;&lt;p&gt;第二，手动创建子表和索引&lt;/p&gt;&lt;p&gt;我们在 psql 内查看父表和子表。（为了照顾页面宽度，删除了表格的部分栏位）&lt;/p&gt;&lt;p&gt;到这里就完成了。这是原生的分区表，不像上一篇用继承实现的分区表需要编写 function 和 trigger 来做父表到子表的重定向。&lt;/p&gt;&lt;p&gt;我们插入 32 条测试数据试一下。PG 返回 &lt;/p&gt;&lt;p&gt;再看看两张子表的行数量。分别为 22 行和 10 行，说明数据正确地写入了相应的子表。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。我们在原生分区表中手动新增子表是相对很方便了，因此只需在操作系统或者应用软件层面执行定时任务：在特定时机“拼接”出下面的 SQL 执行即可。&lt;/p&gt;&lt;p&gt;下面的代码用于移除子表。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了声明式分区（原生分区表）的基本操作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;前两篇文章（&lt;/p&gt;&lt;p&gt;本文记录了使用 &lt;/p&gt;&lt;p&gt;对于 Windows 用户，需要自己克隆代码（&lt;/p&gt;&lt;p&gt;构建后，预期得到的文件有：&lt;/p&gt;&lt;p&gt;但是阅读 &lt;/p&gt;&lt;p&gt;通过搜索 github issues，找到了&lt;/p&gt;&lt;p&gt;直接在 git bash 内执行 &lt;/p&gt;&lt;p&gt;把上一步得到的 &lt;/p&gt;&lt;p&gt;验证如下。&lt;/p&gt;&lt;p&gt;我们直接使用 pg_partman.create_parent 按月来创建分区表：&lt;/p&gt;&lt;p&gt;查看 &lt;/p&gt;&lt;p&gt;就这么简单。&lt;/p&gt;&lt;p&gt;贴一下 create_parent 的完整签名备忘。&lt;/p&gt;&lt;p&gt;使用 &lt;/p&gt;&lt;p&gt;可以手动针对 dbo.test3 进行维护：&lt;/p&gt;&lt;p&gt;上面是我们在某个数据库下，手动指定某一张表，因此传入了表名作为参数；自动维护时，我们可以调用使用默认参数（&lt;/p&gt;&lt;p&gt;我们只需编写一个小程序，在连接字符串内拼接好指定的数据库名字，调用即可；大概如下。&lt;/p&gt;&lt;p&gt;维护分区，不但包含新建分区，也包含丢弃分区。&lt;/p&gt;&lt;p&gt;如何丢弃分区？&lt;/p&gt;&lt;p&gt;对于本文中基于时间（&lt;/p&gt;&lt;p&gt;本文介绍了 pg_partman 这个工具的构建、安装和使用。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近工作之余，我在学习 PostgreSQL 的分区表。&lt;/p&gt;&lt;p&gt;被分区的表叫做 partitioned table，下文用“父表”这个词；分出的若干个表叫做 partitions，下文用“子表”这个词。&lt;/p&gt;&lt;p&gt;我在 Windows 10 上使用 PostgreSQL 14（以下简称 PG），从&lt;/p&gt;&lt;p&gt;假定有父表叫做 &lt;/p&gt;&lt;p&gt;第一，用户通过 &lt;/p&gt;&lt;p&gt;第二，编写 function 来实现父表到子表的重定向。&lt;/p&gt;&lt;p&gt;第三，编写 trigger 使得插入新行之前、执行刚刚编写好的 function：&lt;/p&gt;&lt;p&gt;到这里，我们向父表插入数据后，会发现数据实际存储在某个子表中。同时，对父表执行 &lt;/p&gt;&lt;p&gt;使用 ORM 框架的开发者需要注意，我们向父表插入 1 行数据， ORM 框架预期的返回是 &lt;/p&gt;&lt;p&gt;我们可通过修改原 function、增加新的 function 和 trigger 作为应变方法 &lt;/p&gt;&lt;p&gt;新增 function 和 trigger，用于插入后的动作。&lt;/p&gt;&lt;p&gt;这样 ORM 框架就不会抱怨了。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。随着时间的推移，如何自动创建新的分区呢？&lt;/p&gt;&lt;p&gt;我个人比较偏向于：&lt;/p&gt;&lt;p&gt;除了新增分区，维护往往也需要删除过时数据。这个很方便：&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了继承式分区的基本操作、应用此方式时需为 ORM 框架做的额外工作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;我的场景是客户端/服务器（C/S）版桌面工控软件（.NET），有两类数据库使用工况：&lt;/p&gt;&lt;p&gt;第一种工况下我使用 SQLite 嵌入式数据库，用 Dapper 微框架作为 O/RM（对象-关系映射）来操作数据库。第二种工况下我使用 SQL Server 2019 Express 或 PostgreSQL 作为数据库，使用 Entity Framework 6（以下简称 EF6）作为 O/RM 框架。&lt;/p&gt;&lt;p&gt;在快速批量部署时，SQLite 无需安装配置的特性是很吸引人的。我不想每台机器部署时，都要拷贝大体积的数据库软件安装包，执行安装、配置等操作，这对于现场实施人员来说是不友好的，也是有错误操作风险的。因此在能够只用 SQLite 的场合，我尽可能会用它。&lt;/p&gt;&lt;p&gt;安装软件包后，是直接通过 ADO.NET provider 来操作数据库，比较冗长。&lt;/p&gt;&lt;p&gt;而使用 Dapper &lt;/p&gt;&lt;p&gt;Dapper 的性能是很好的，它是由 Stack Overflow 的工程师们发起的开源项目，用于 Stack Overflow 的生产环境中。&lt;/p&gt;&lt;p&gt;当遇到需要存储大量数据，并且表结构经常要变化的项目时，我选用 SQL Server 2019 Express 和 Entity Framework 的搭配。先说 Entity Framework &lt;/p&gt;&lt;p&gt;EF 解放了手写 SQL、手工管理数据库连接的工作，大大提高了开发效率，程序员可以直接用 &lt;/p&gt;&lt;p&gt;很多人说 EF6 性能不行，但是对我来说足够了。几个小贴士可以显著提升性能：&lt;/p&gt;&lt;p&gt;另一个我喜欢的功能是自动迁移（Auto Migration）。当模型发生变化时，例如增加数据表栏位（column）时，在控制台执行 &lt;/p&gt;&lt;p&gt;说完了 EF，再说回 SQL Server。我对 SQL Server 没有任何抱怨。&lt;/p&gt;&lt;p&gt;不过由于我使用了免费版本（2019 Express），它的限制之一是数据库文件的&lt;/p&gt;&lt;p&gt;我选择的替代是 PostgreSQL &lt;/p&gt;&lt;p&gt;.NET 下使用 PG 往往用到如下这几个包。&lt;/p&gt;&lt;p&gt;使用 EF 操作 PG 也不是没有坑，&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近我从 Codesys 中国购买了学习套件：树莓派4B、Codesys 许可证和《开放式控制系统编程技术》这本书。&lt;/p&gt;&lt;p&gt;五一假期试玩了一把。以下凭借记忆叙述大致步骤，作为备忘，也希望帮助从搜索引擎过来的朋友。&lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;树莓派的相关操作，例如配置 ssh / vnc server、配置网络接口 eth0 等操作不在此赘述，可参考 &lt;/p&gt;&lt;p&gt;大致步骤：&lt;/p&gt;&lt;p&gt;完成授权后启动 runtime，尝试新建工程并下载，确保正常工作，至此树莓派变身为一台软 PLC。&lt;/p&gt;&lt;p&gt;使用网络交换机将设备连接到一起，我的设备情况如下。&lt;/p&gt;&lt;p&gt;注意：我遇到了树莓派的 eth0 无法 ping 通外部设备的情况。搜索后执行了 &lt;/p&gt;&lt;p&gt;下载、安装设备的 GSD 文件操作，这里也不提。&lt;/p&gt;&lt;p&gt;关键步骤：&lt;/p&gt;&lt;p&gt;硬件组态完成后，进行 I/O 映射。&lt;/p&gt;&lt;p&gt;我使用的硬件：BK9053 耦合器 &lt;/p&gt;&lt;p&gt;完成映射后发现无法手动强制信号……最后发现用代码置位信号后，可以手动强制了，不解。&lt;/p&gt;&lt;p&gt;最后录制了一个“跑马灯”效果的 demo：循环点亮每个数字输出通道。&lt;/p&gt;&lt;p&gt;https://v.youku.com/v_show/id_XNDY2MzY4MjAzMg==.html&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近公司让我紧急做个 FANUC 机器人的拆垛仿真，需要：&lt;/p&gt;&lt;p&gt;前者这条约束，导致没法用 RoboDK 这样的第三方软件。&lt;/p&gt;&lt;p&gt;于是不得不用 FANUC 的 Roboguide 了，虽然我接触 FANUC 好些年了，但只用 Roboguide 做程序代码的仿真和基本的布局验证。&lt;/p&gt;&lt;p&gt;好一顿折腾，记录如下。&lt;/p&gt;&lt;p&gt;我会从本次任务中抽取几个主题，构成本文内容：&lt;/p&gt;&lt;p&gt;除去机器人模型外，需要若干基本模型，用于支持仿真。例如，搬运对象：箱子（立方体）；托盘；机器人工具（吸盘）。&lt;/p&gt;&lt;p&gt;可以通过文件来导入，也可以在 Roboguide 内进行简单几何体的建模。模型导入或创建完毕后，依据布局图进行相应的模型摆放。&lt;/p&gt;&lt;p&gt;如何安装机器人工具这类操作，不在此赘述，请查找自带的帮助文档，或者按照你习惯的操作进行探索。&lt;/p&gt;&lt;p&gt;Roboguide 给框定的操作逻辑是，用户先想好导入的模型是什么类别（machine / fixture / part / obstacle），然后再导入。&lt;/p&gt;&lt;p&gt;摘录自帮助文档的《Working with Parts》章节：&lt;/p&gt;&lt;p&gt;例如，已经导入了类别为 Part 的模型，但是它不能直接使用；用户需要将它与夹具或机器人工具关联。&lt;/p&gt;&lt;p&gt;下表为手工生成垛型的操作。&lt;/p&gt;&lt;p&gt;为了实现仿真抓放，我们先配置机器人工具以实现抓取、放置的动画效果，下表的操作将机器人工具（EOAT）与 parts 关联。&lt;/p&gt;&lt;p&gt;将机器人工具与 part 关联后，如何实现 attach / detach 呢？Roboguide 提供了一种特别类型的程序，叫做仿真程序（Simulation program）；它与真实的机器人程序（TPE / KAREL 程序）不同，只能用于仿真环境。&lt;/p&gt;&lt;p&gt;从 Teach 菜单添加仿真程序，例如 &lt;/p&gt;&lt;p&gt;同理，可以添加放置的程序（使用 &lt;/p&gt;&lt;p&gt;终于到了综合部分：如何让机器人运动到某个位姿，抓取箱子，运动到另一个位姿，放置箱子。&lt;/p&gt;&lt;p&gt;如果抓取位姿、放置位姿都是固定的，那么很简单：添加仿真程序，插入类似 &lt;/p&gt;&lt;p&gt;但是本任务的特点是：&lt;/p&gt;&lt;p&gt;好，这“一推一拉”的形势，决定了我们肯定要用聪明些的方法。&lt;/p&gt;&lt;p&gt;帮助文档的《Teach a program》章含有 Combining simulation and TP programs into a single animation program 小节，完成本任务需要用到仿真程序和机器人程序的结合。因为仿真程序（Simulation program）的指令和能力非常有限。&lt;/p&gt;&lt;p&gt;我的思路为，得到箱子位姿后，设法计算、生成两个机器人程序（&lt;/p&gt;&lt;p&gt;细心的读者会发现，在仿真程序中使用了全局的数字寄存器 &lt;/p&gt;&lt;p&gt;5.3 节得到了箱子参考托盘的位姿，实际使用时应该把箱子位姿变换到机器人世界坐标系下面：托盘位姿是已知的，所以箱子的绝对位姿是可以在外部算出来的。&lt;/p&gt;&lt;p&gt;得到箱子的绝对位姿后，至少要按照箱子的 Z 值排序，以便进行从高到低的拆垛（废话）。当吸盘比箱子大时，同层的箱子也不能随便吸取，否则就露馅了；而是应当用吸盘边角去吸取。这个涉及到计算，为了减少麻烦，本次通过设置机器人工具的 part offset 来规避。&lt;/p&gt;&lt;p&gt;到这里，我们已经手握 36 个处理后（排序）的箱子位姿，就可以根据如下的 FANUC TPE 程序的模板来生成 &lt;/p&gt;&lt;p&gt;科普：TPE 程序的源文件后缀为 &lt;/p&gt;&lt;p&gt;至此，仿真程序就能调用生成的机器人程序（包含接近、吸取、离开箱子的位姿），实现精确运动到每个箱子上表面，抓取和放置了。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;近期出差发生了一件很有意思的事情。&lt;/p&gt;&lt;p&gt;工控机上跑着一个命令行程序（该程序具备网络通信功能），它会频繁打印信息到标准输出。由于需要定期查看输出的最新信息，我们习惯按住鼠标左键拖选关键输出（此时进入了 cmd.exe 的快速编辑模式），这样就能高亮显示了，阅读起来轻松些。&lt;/p&gt;&lt;p&gt;看完输出后，人就走开了（此时仍然维持着快速编辑模式）。&lt;/p&gt;&lt;p&gt;不久，我们发现似乎程序在某个时间点，本该收到外部网络数据，但是迟迟收不到。纳闷。&lt;/p&gt;&lt;p&gt;于是不得不中断设备的运行，切到手动模式操作。&lt;/p&gt;&lt;p&gt;后来同事提及，他碰到过类似事情，最后发现在选中 cmd.exe 的输出时，会阻塞程序的运行。&lt;/p&gt;&lt;p&gt;我写了几行代码验证，果然如此。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;许久没做 KRC4 的编程，其实当前工作上也不需要，只是想强制自己练练手。&lt;/p&gt;&lt;p&gt;在写了几十行代码后，我想将机器人本体可视化出来，这样能带来直观的调试感受。因为我没有 KUKA.Sim，所以想到用 RoboDK 来做这件事情。&lt;/p&gt;&lt;p&gt;解释一下：&lt;/p&gt;&lt;p&gt;如果你不喜欢使用这套私有的连接技术，可自行使用 TCP/IP socket 来实现；那么你就需要在 KRC 中安装 Ethernet KRL 来让库卡的编程语言（KRL）具备网络通信能力，同时在 PC 端利用 RoboDK 的脚本功能实现网络通信。&lt;/p&gt;&lt;p&gt;要想可视化机器人运动，只要能快速频繁地读取机器人的各关节度数就行。对于 KRC，就是频繁读取系统变量 &lt;/p&gt;&lt;p&gt;RoboDK API: &lt;/p&gt;&lt;p&gt;当然，需要先创建带有 KUKA 机器人的 RoboDK 工程，请使用 KR 210-2 这款本体，它是 OfficeLite 使用的本体型号。&lt;/p&gt;&lt;p&gt;我在 RoboDK 中创建了两个脚本，一个是定期频繁读取机器人关节读数的脚本（&lt;/p&gt;&lt;p&gt;优酷&lt;/p&gt;&lt;p&gt;Youtube&lt;/p&gt;
                ]]>
        </content>
        </entry>

        <entry>
                <title>PLB 中的几个坐标系</title>
                <link href="http://blog.linuxsand.info/ref_frames_in_sick_plb.html" />
                <id>http://blog.linuxsand.info/ref_frames_in_sick_plb.html</id>
                <updated>2019-11-25T22:22:22Z</updated>
                <content type="html">
                <![CDATA[
&lt;p&gt;RevB 与 RevA 版本的规格区别：&lt;/p&gt;&lt;p&gt;RevB 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;这个版本开始，命名方式使用 &lt;/p&gt;&lt;p&gt;这个版本是打样迭代版本，主要规格：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;（为何直接从 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;上位机软件支持本页面所有列出的型号；它分为两个部分，一是“开箱即用”的实用工具（Utility），连接信号板后，能够快速刷新信号状态和强制数字信号输出（可批量连续测试输出通道）；
二为开发包（SDK），目前支持 &lt;/p&gt;&lt;p&gt;请到产品支持页 &lt;/p&gt;&lt;p&gt;将和我的朋友“涛哥工业科技（TaoRobotics）”联合量产，敬请期待。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;第一，用户在创建原生分区表时需用 &lt;/p&gt;&lt;p&gt;第二，手动创建子表和索引&lt;/p&gt;&lt;p&gt;我们在 psql 内查看父表和子表。（为了照顾页面宽度，删除了表格的部分栏位）&lt;/p&gt;&lt;p&gt;到这里就完成了。这是原生的分区表，不像上一篇用继承实现的分区表需要编写 function 和 trigger 来做父表到子表的重定向。&lt;/p&gt;&lt;p&gt;我们插入 32 条测试数据试一下。PG 返回 &lt;/p&gt;&lt;p&gt;再看看两张子表的行数量。分别为 22 行和 10 行，说明数据正确地写入了相应的子表。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。我们在原生分区表中手动新增子表是相对很方便了，因此只需在操作系统或者应用软件层面执行定时任务：在特定时机“拼接”出下面的 SQL 执行即可。&lt;/p&gt;&lt;p&gt;下面的代码用于移除子表。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了声明式分区（原生分区表）的基本操作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;前两篇文章（&lt;/p&gt;&lt;p&gt;本文记录了使用 &lt;/p&gt;&lt;p&gt;对于 Windows 用户，需要自己克隆代码（&lt;/p&gt;&lt;p&gt;构建后，预期得到的文件有：&lt;/p&gt;&lt;p&gt;但是阅读 &lt;/p&gt;&lt;p&gt;通过搜索 github issues，找到了&lt;/p&gt;&lt;p&gt;直接在 git bash 内执行 &lt;/p&gt;&lt;p&gt;把上一步得到的 &lt;/p&gt;&lt;p&gt;验证如下。&lt;/p&gt;&lt;p&gt;我们直接使用 pg_partman.create_parent 按月来创建分区表：&lt;/p&gt;&lt;p&gt;查看 &lt;/p&gt;&lt;p&gt;就这么简单。&lt;/p&gt;&lt;p&gt;贴一下 create_parent 的完整签名备忘。&lt;/p&gt;&lt;p&gt;使用 &lt;/p&gt;&lt;p&gt;可以手动针对 dbo.test3 进行维护：&lt;/p&gt;&lt;p&gt;上面是我们在某个数据库下，手动指定某一张表，因此传入了表名作为参数；自动维护时，我们可以调用使用默认参数（&lt;/p&gt;&lt;p&gt;我们只需编写一个小程序，在连接字符串内拼接好指定的数据库名字，调用即可；大概如下。&lt;/p&gt;&lt;p&gt;维护分区，不但包含新建分区，也包含丢弃分区。&lt;/p&gt;&lt;p&gt;如何丢弃分区？&lt;/p&gt;&lt;p&gt;对于本文中基于时间（&lt;/p&gt;&lt;p&gt;本文介绍了 pg_partman 这个工具的构建、安装和使用。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近工作之余，我在学习 PostgreSQL 的分区表。&lt;/p&gt;&lt;p&gt;被分区的表叫做 partitioned table，下文用“父表”这个词；分出的若干个表叫做 partitions，下文用“子表”这个词。&lt;/p&gt;&lt;p&gt;我在 Windows 10 上使用 PostgreSQL 14（以下简称 PG），从&lt;/p&gt;&lt;p&gt;假定有父表叫做 &lt;/p&gt;&lt;p&gt;第一，用户通过 &lt;/p&gt;&lt;p&gt;第二，编写 function 来实现父表到子表的重定向。&lt;/p&gt;&lt;p&gt;第三，编写 trigger 使得插入新行之前、执行刚刚编写好的 function：&lt;/p&gt;&lt;p&gt;到这里，我们向父表插入数据后，会发现数据实际存储在某个子表中。同时，对父表执行 &lt;/p&gt;&lt;p&gt;使用 ORM 框架的开发者需要注意，我们向父表插入 1 行数据， ORM 框架预期的返回是 &lt;/p&gt;&lt;p&gt;我们可通过修改原 function、增加新的 function 和 trigger 作为应变方法 &lt;/p&gt;&lt;p&gt;新增 function 和 trigger，用于插入后的动作。&lt;/p&gt;&lt;p&gt;这样 ORM 框架就不会抱怨了。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。随着时间的推移，如何自动创建新的分区呢？&lt;/p&gt;&lt;p&gt;我个人比较偏向于：&lt;/p&gt;&lt;p&gt;除了新增分区，维护往往也需要删除过时数据。这个很方便：&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了继承式分区的基本操作、应用此方式时需为 ORM 框架做的额外工作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;我的场景是客户端/服务器（C/S）版桌面工控软件（.NET），有两类数据库使用工况：&lt;/p&gt;&lt;p&gt;第一种工况下我使用 SQLite 嵌入式数据库，用 Dapper 微框架作为 O/RM（对象-关系映射）来操作数据库。第二种工况下我使用 SQL Server 2019 Express 或 PostgreSQL 作为数据库，使用 Entity Framework 6（以下简称 EF6）作为 O/RM 框架。&lt;/p&gt;&lt;p&gt;在快速批量部署时，SQLite 无需安装配置的特性是很吸引人的。我不想每台机器部署时，都要拷贝大体积的数据库软件安装包，执行安装、配置等操作，这对于现场实施人员来说是不友好的，也是有错误操作风险的。因此在能够只用 SQLite 的场合，我尽可能会用它。&lt;/p&gt;&lt;p&gt;安装软件包后，是直接通过 ADO.NET provider 来操作数据库，比较冗长。&lt;/p&gt;&lt;p&gt;而使用 Dapper &lt;/p&gt;&lt;p&gt;Dapper 的性能是很好的，它是由 Stack Overflow 的工程师们发起的开源项目，用于 Stack Overflow 的生产环境中。&lt;/p&gt;&lt;p&gt;当遇到需要存储大量数据，并且表结构经常要变化的项目时，我选用 SQL Server 2019 Express 和 Entity Framework 的搭配。先说 Entity Framework &lt;/p&gt;&lt;p&gt;EF 解放了手写 SQL、手工管理数据库连接的工作，大大提高了开发效率，程序员可以直接用 &lt;/p&gt;&lt;p&gt;很多人说 EF6 性能不行，但是对我来说足够了。几个小贴士可以显著提升性能：&lt;/p&gt;&lt;p&gt;另一个我喜欢的功能是自动迁移（Auto Migration）。当模型发生变化时，例如增加数据表栏位（column）时，在控制台执行 &lt;/p&gt;&lt;p&gt;说完了 EF，再说回 SQL Server。我对 SQL Server 没有任何抱怨。&lt;/p&gt;&lt;p&gt;不过由于我使用了免费版本（2019 Express），它的限制之一是数据库文件的&lt;/p&gt;&lt;p&gt;我选择的替代是 PostgreSQL &lt;/p&gt;&lt;p&gt;.NET 下使用 PG 往往用到如下这几个包。&lt;/p&gt;&lt;p&gt;使用 EF 操作 PG 也不是没有坑，&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近我从 Codesys 中国购买了学习套件：树莓派4B、Codesys 许可证和《开放式控制系统编程技术》这本书。&lt;/p&gt;&lt;p&gt;五一假期试玩了一把。以下凭借记忆叙述大致步骤，作为备忘，也希望帮助从搜索引擎过来的朋友。&lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;树莓派的相关操作，例如配置 ssh / vnc server、配置网络接口 eth0 等操作不在此赘述，可参考 &lt;/p&gt;&lt;p&gt;大致步骤：&lt;/p&gt;&lt;p&gt;完成授权后启动 runtime，尝试新建工程并下载，确保正常工作，至此树莓派变身为一台软 PLC。&lt;/p&gt;&lt;p&gt;使用网络交换机将设备连接到一起，我的设备情况如下。&lt;/p&gt;&lt;p&gt;注意：我遇到了树莓派的 eth0 无法 ping 通外部设备的情况。搜索后执行了 &lt;/p&gt;&lt;p&gt;下载、安装设备的 GSD 文件操作，这里也不提。&lt;/p&gt;&lt;p&gt;关键步骤：&lt;/p&gt;&lt;p&gt;硬件组态完成后，进行 I/O 映射。&lt;/p&gt;&lt;p&gt;我使用的硬件：BK9053 耦合器 &lt;/p&gt;&lt;p&gt;完成映射后发现无法手动强制信号……最后发现用代码置位信号后，可以手动强制了，不解。&lt;/p&gt;&lt;p&gt;最后录制了一个“跑马灯”效果的 demo：循环点亮每个数字输出通道。&lt;/p&gt;&lt;p&gt;https://v.youku.com/v_show/id_XNDY2MzY4MjAzMg==.html&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近公司让我紧急做个 FANUC 机器人的拆垛仿真，需要：&lt;/p&gt;&lt;p&gt;前者这条约束，导致没法用 RoboDK 这样的第三方软件。&lt;/p&gt;&lt;p&gt;于是不得不用 FANUC 的 Roboguide 了，虽然我接触 FANUC 好些年了，但只用 Roboguide 做程序代码的仿真和基本的布局验证。&lt;/p&gt;&lt;p&gt;好一顿折腾，记录如下。&lt;/p&gt;&lt;p&gt;我会从本次任务中抽取几个主题，构成本文内容：&lt;/p&gt;&lt;p&gt;除去机器人模型外，需要若干基本模型，用于支持仿真。例如，搬运对象：箱子（立方体）；托盘；机器人工具（吸盘）。&lt;/p&gt;&lt;p&gt;可以通过文件来导入，也可以在 Roboguide 内进行简单几何体的建模。模型导入或创建完毕后，依据布局图进行相应的模型摆放。&lt;/p&gt;&lt;p&gt;如何安装机器人工具这类操作，不在此赘述，请查找自带的帮助文档，或者按照你习惯的操作进行探索。&lt;/p&gt;&lt;p&gt;Roboguide 给框定的操作逻辑是，用户先想好导入的模型是什么类别（machine / fixture / part / obstacle），然后再导入。&lt;/p&gt;&lt;p&gt;摘录自帮助文档的《Working with Parts》章节：&lt;/p&gt;&lt;p&gt;例如，已经导入了类别为 Part 的模型，但是它不能直接使用；用户需要将它与夹具或机器人工具关联。&lt;/p&gt;&lt;p&gt;下表为手工生成垛型的操作。&lt;/p&gt;&lt;p&gt;为了实现仿真抓放，我们先配置机器人工具以实现抓取、放置的动画效果，下表的操作将机器人工具（EOAT）与 parts 关联。&lt;/p&gt;&lt;p&gt;将机器人工具与 part 关联后，如何实现 attach / detach 呢？Roboguide 提供了一种特别类型的程序，叫做仿真程序（Simulation program）；它与真实的机器人程序（TPE / KAREL 程序）不同，只能用于仿真环境。&lt;/p&gt;&lt;p&gt;从 Teach 菜单添加仿真程序，例如 &lt;/p&gt;&lt;p&gt;同理，可以添加放置的程序（使用 &lt;/p&gt;&lt;p&gt;终于到了综合部分：如何让机器人运动到某个位姿，抓取箱子，运动到另一个位姿，放置箱子。&lt;/p&gt;&lt;p&gt;如果抓取位姿、放置位姿都是固定的，那么很简单：添加仿真程序，插入类似 &lt;/p&gt;&lt;p&gt;但是本任务的特点是：&lt;/p&gt;&lt;p&gt;好，这“一推一拉”的形势，决定了我们肯定要用聪明些的方法。&lt;/p&gt;&lt;p&gt;帮助文档的《Teach a program》章含有 Combining simulation and TP programs into a single animation program 小节，完成本任务需要用到仿真程序和机器人程序的结合。因为仿真程序（Simulation program）的指令和能力非常有限。&lt;/p&gt;&lt;p&gt;我的思路为，得到箱子位姿后，设法计算、生成两个机器人程序（&lt;/p&gt;&lt;p&gt;细心的读者会发现，在仿真程序中使用了全局的数字寄存器 &lt;/p&gt;&lt;p&gt;5.3 节得到了箱子参考托盘的位姿，实际使用时应该把箱子位姿变换到机器人世界坐标系下面：托盘位姿是已知的，所以箱子的绝对位姿是可以在外部算出来的。&lt;/p&gt;&lt;p&gt;得到箱子的绝对位姿后，至少要按照箱子的 Z 值排序，以便进行从高到低的拆垛（废话）。当吸盘比箱子大时，同层的箱子也不能随便吸取，否则就露馅了；而是应当用吸盘边角去吸取。这个涉及到计算，为了减少麻烦，本次通过设置机器人工具的 part offset 来规避。&lt;/p&gt;&lt;p&gt;到这里，我们已经手握 36 个处理后（排序）的箱子位姿，就可以根据如下的 FANUC TPE 程序的模板来生成 &lt;/p&gt;&lt;p&gt;科普：TPE 程序的源文件后缀为 &lt;/p&gt;&lt;p&gt;至此，仿真程序就能调用生成的机器人程序（包含接近、吸取、离开箱子的位姿），实现精确运动到每个箱子上表面，抓取和放置了。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;近期出差发生了一件很有意思的事情。&lt;/p&gt;&lt;p&gt;工控机上跑着一个命令行程序（该程序具备网络通信功能），它会频繁打印信息到标准输出。由于需要定期查看输出的最新信息，我们习惯按住鼠标左键拖选关键输出（此时进入了 cmd.exe 的快速编辑模式），这样就能高亮显示了，阅读起来轻松些。&lt;/p&gt;&lt;p&gt;看完输出后，人就走开了（此时仍然维持着快速编辑模式）。&lt;/p&gt;&lt;p&gt;不久，我们发现似乎程序在某个时间点，本该收到外部网络数据，但是迟迟收不到。纳闷。&lt;/p&gt;&lt;p&gt;于是不得不中断设备的运行，切到手动模式操作。&lt;/p&gt;&lt;p&gt;后来同事提及，他碰到过类似事情，最后发现在选中 cmd.exe 的输出时，会阻塞程序的运行。&lt;/p&gt;&lt;p&gt;我写了几行代码验证，果然如此。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;许久没做 KRC4 的编程，其实当前工作上也不需要，只是想强制自己练练手。&lt;/p&gt;&lt;p&gt;在写了几十行代码后，我想将机器人本体可视化出来，这样能带来直观的调试感受。因为我没有 KUKA.Sim，所以想到用 RoboDK 来做这件事情。&lt;/p&gt;&lt;p&gt;解释一下：&lt;/p&gt;&lt;p&gt;如果你不喜欢使用这套私有的连接技术，可自行使用 TCP/IP socket 来实现；那么你就需要在 KRC 中安装 Ethernet KRL 来让库卡的编程语言（KRL）具备网络通信能力，同时在 PC 端利用 RoboDK 的脚本功能实现网络通信。&lt;/p&gt;&lt;p&gt;要想可视化机器人运动，只要能快速频繁地读取机器人的各关节度数就行。对于 KRC，就是频繁读取系统变量 &lt;/p&gt;&lt;p&gt;RoboDK API: &lt;/p&gt;&lt;p&gt;当然，需要先创建带有 KUKA 机器人的 RoboDK 工程，请使用 KR 210-2 这款本体，它是 OfficeLite 使用的本体型号。&lt;/p&gt;&lt;p&gt;我在 RoboDK 中创建了两个脚本，一个是定期频繁读取机器人关节读数的脚本（&lt;/p&gt;&lt;p&gt;优酷&lt;/p&gt;&lt;p&gt;Youtube&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;PLB 是 SICK 的视觉产品，可以理解为一套软硬件结合的系统，全称是 Part Localization in Bins，即箱中工件定位。它用于引导机器人实现 &lt;/p&gt;&lt;p&gt;和 SICK China 合作，我实现了 FANUC（发那科） 和 KAWASAKI（川崎）的通信接口和代码示例，覆盖了 PLB 5.2 的基础功能。&lt;/p&gt;&lt;p&gt;本文仅涉及 PLB 中的几个坐标系，对初入 3D 视觉的朋友也许会有帮助。内容和截图来源于 PLB 5.2 版本操作手册中的 3.2.4 Reference frames 章节。&lt;/p&gt;&lt;p&gt;PLB 最终将计算出“工件坐标系（相对于机器人坐标系）”和“抓手相对于工件坐标系的位姿”。&lt;/p&gt;&lt;p&gt;A 是工件数模中的参考坐标系，B 是调整后的坐标系。part frame 的数值是相对于机器人坐标系的（事先需要完成标定），由 PLB 计算而来。&lt;/p&gt;&lt;p&gt;A 是抓手数模中的参考坐标系，C 是调整过后的坐标系（原点需要和真实的 TCP 重合），B 是 A ---&gt; C 的变换。&lt;/p&gt;&lt;p&gt;A 是调整过后的抓手坐标系，B 是调整过后的工件坐标系。&lt;/p&gt;&lt;p&gt;如果是相对简单的应用，可以让 PLB 为你计算好真正的 pick pose（即 absolute tool frame），在机器人接口中指定使用 absolute tool frame 即可。&lt;/p&gt;&lt;p&gt;但是在使用相对工具坐标系（relative tool frame）时，PLB 输出的数据不能直接让机器人运动过去，而是需要先自行做变换，见&lt;/p&gt;&lt;p&gt;更复杂的情况是，某些工件从横截面看是轴对称的，只需要一种抓取姿态就可以应付；为此 PLB 引入了 vertical correction，即垂直校正。那么，这时：&lt;/p&gt;&lt;p&gt;摘取 PLB 5.2 机器人接口支持的字段。    &lt;/p&gt;&lt;p&gt;拓展：为了放工件时更加灵活和优雅，也可以根据这些坐标系数据计算出一个新的机器人工具数据，新工具的 TCP 与工件的坐标系原点重合。手册里并没有指出如何变换。&lt;/p&gt;&lt;p&gt;但这实际上就是求出 tool 1 ---&gt; tool 2 的变换关系 T。&lt;/p&gt;
                ]]>
        </content>
        </entry>

        <entry>
                <title>Convert Fanuc karel timestamp to string</title>
                <link href="http://blog.linuxsand.info/fanuc_karel_timestamp_to_string.html" />
                <id>http://blog.linuxsand.info/fanuc_karel_timestamp_to_string.html</id>
                <updated>2019-11-25T22:22:22Z</updated>
                <content type="html">
                <![CDATA[
&lt;p&gt;RevB 的接线示意图如下：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;这个版本开始，命名方式使用 &lt;/p&gt;&lt;p&gt;这个版本是打样迭代版本，主要规格：&lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;（为何直接从 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;如图像未加载，请点击 &lt;/p&gt;&lt;p&gt;上位机软件支持本页面所有列出的型号；它分为两个部分，一是“开箱即用”的实用工具（Utility），连接信号板后，能够快速刷新信号状态和强制数字信号输出（可批量连续测试输出通道）；
二为开发包（SDK），目前支持 &lt;/p&gt;&lt;p&gt;请到产品支持页 &lt;/p&gt;&lt;p&gt;将和我的朋友“涛哥工业科技（TaoRobotics）”联合量产，敬请期待。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;第一，用户在创建原生分区表时需用 &lt;/p&gt;&lt;p&gt;第二，手动创建子表和索引&lt;/p&gt;&lt;p&gt;我们在 psql 内查看父表和子表。（为了照顾页面宽度，删除了表格的部分栏位）&lt;/p&gt;&lt;p&gt;到这里就完成了。这是原生的分区表，不像上一篇用继承实现的分区表需要编写 function 和 trigger 来做父表到子表的重定向。&lt;/p&gt;&lt;p&gt;我们插入 32 条测试数据试一下。PG 返回 &lt;/p&gt;&lt;p&gt;再看看两张子表的行数量。分别为 22 行和 10 行，说明数据正确地写入了相应的子表。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。我们在原生分区表中手动新增子表是相对很方便了，因此只需在操作系统或者应用软件层面执行定时任务：在特定时机“拼接”出下面的 SQL 执行即可。&lt;/p&gt;&lt;p&gt;下面的代码用于移除子表。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了声明式分区（原生分区表）的基本操作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;前两篇文章（&lt;/p&gt;&lt;p&gt;本文记录了使用 &lt;/p&gt;&lt;p&gt;对于 Windows 用户，需要自己克隆代码（&lt;/p&gt;&lt;p&gt;构建后，预期得到的文件有：&lt;/p&gt;&lt;p&gt;但是阅读 &lt;/p&gt;&lt;p&gt;通过搜索 github issues，找到了&lt;/p&gt;&lt;p&gt;直接在 git bash 内执行 &lt;/p&gt;&lt;p&gt;把上一步得到的 &lt;/p&gt;&lt;p&gt;验证如下。&lt;/p&gt;&lt;p&gt;我们直接使用 pg_partman.create_parent 按月来创建分区表：&lt;/p&gt;&lt;p&gt;查看 &lt;/p&gt;&lt;p&gt;就这么简单。&lt;/p&gt;&lt;p&gt;贴一下 create_parent 的完整签名备忘。&lt;/p&gt;&lt;p&gt;使用 &lt;/p&gt;&lt;p&gt;可以手动针对 dbo.test3 进行维护：&lt;/p&gt;&lt;p&gt;上面是我们在某个数据库下，手动指定某一张表，因此传入了表名作为参数；自动维护时，我们可以调用使用默认参数（&lt;/p&gt;&lt;p&gt;我们只需编写一个小程序，在连接字符串内拼接好指定的数据库名字，调用即可；大概如下。&lt;/p&gt;&lt;p&gt;维护分区，不但包含新建分区，也包含丢弃分区。&lt;/p&gt;&lt;p&gt;如何丢弃分区？&lt;/p&gt;&lt;p&gt;对于本文中基于时间（&lt;/p&gt;&lt;p&gt;本文介绍了 pg_partman 这个工具的构建、安装和使用。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近工作之余，我在学习 PostgreSQL 的分区表。&lt;/p&gt;&lt;p&gt;被分区的表叫做 partitioned table，下文用“父表”这个词；分出的若干个表叫做 partitions，下文用“子表”这个词。&lt;/p&gt;&lt;p&gt;我在 Windows 10 上使用 PostgreSQL 14（以下简称 PG），从&lt;/p&gt;&lt;p&gt;假定有父表叫做 &lt;/p&gt;&lt;p&gt;第一，用户通过 &lt;/p&gt;&lt;p&gt;第二，编写 function 来实现父表到子表的重定向。&lt;/p&gt;&lt;p&gt;第三，编写 trigger 使得插入新行之前、执行刚刚编写好的 function：&lt;/p&gt;&lt;p&gt;到这里，我们向父表插入数据后，会发现数据实际存储在某个子表中。同时，对父表执行 &lt;/p&gt;&lt;p&gt;使用 ORM 框架的开发者需要注意，我们向父表插入 1 行数据， ORM 框架预期的返回是 &lt;/p&gt;&lt;p&gt;我们可通过修改原 function、增加新的 function 和 trigger 作为应变方法 &lt;/p&gt;&lt;p&gt;新增 function 和 trigger，用于插入后的动作。&lt;/p&gt;&lt;p&gt;这样 ORM 框架就不会抱怨了。&lt;/p&gt;&lt;p&gt;上面的基本操作中，我们创建了固定数量的分区。随着时间的推移，如何自动创建新的分区呢？&lt;/p&gt;&lt;p&gt;我个人比较偏向于：&lt;/p&gt;&lt;p&gt;除了新增分区，维护往往也需要删除过时数据。这个很方便：&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;本文介绍了继承式分区的基本操作、应用此方式时需为 ORM 框架做的额外工作、分区维护和优缺点。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;我的场景是客户端/服务器（C/S）版桌面工控软件（.NET），有两类数据库使用工况：&lt;/p&gt;&lt;p&gt;第一种工况下我使用 SQLite 嵌入式数据库，用 Dapper 微框架作为 O/RM（对象-关系映射）来操作数据库。第二种工况下我使用 SQL Server 2019 Express 或 PostgreSQL 作为数据库，使用 Entity Framework 6（以下简称 EF6）作为 O/RM 框架。&lt;/p&gt;&lt;p&gt;在快速批量部署时，SQLite 无需安装配置的特性是很吸引人的。我不想每台机器部署时，都要拷贝大体积的数据库软件安装包，执行安装、配置等操作，这对于现场实施人员来说是不友好的，也是有错误操作风险的。因此在能够只用 SQLite 的场合，我尽可能会用它。&lt;/p&gt;&lt;p&gt;安装软件包后，是直接通过 ADO.NET provider 来操作数据库，比较冗长。&lt;/p&gt;&lt;p&gt;而使用 Dapper &lt;/p&gt;&lt;p&gt;Dapper 的性能是很好的，它是由 Stack Overflow 的工程师们发起的开源项目，用于 Stack Overflow 的生产环境中。&lt;/p&gt;&lt;p&gt;当遇到需要存储大量数据，并且表结构经常要变化的项目时，我选用 SQL Server 2019 Express 和 Entity Framework 的搭配。先说 Entity Framework &lt;/p&gt;&lt;p&gt;EF 解放了手写 SQL、手工管理数据库连接的工作，大大提高了开发效率，程序员可以直接用 &lt;/p&gt;&lt;p&gt;很多人说 EF6 性能不行，但是对我来说足够了。几个小贴士可以显著提升性能：&lt;/p&gt;&lt;p&gt;另一个我喜欢的功能是自动迁移（Auto Migration）。当模型发生变化时，例如增加数据表栏位（column）时，在控制台执行 &lt;/p&gt;&lt;p&gt;说完了 EF，再说回 SQL Server。我对 SQL Server 没有任何抱怨。&lt;/p&gt;&lt;p&gt;不过由于我使用了免费版本（2019 Express），它的限制之一是数据库文件的&lt;/p&gt;&lt;p&gt;我选择的替代是 PostgreSQL &lt;/p&gt;&lt;p&gt;.NET 下使用 PG 往往用到如下这几个包。&lt;/p&gt;&lt;p&gt;使用 EF 操作 PG 也不是没有坑，&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近我从 Codesys 中国购买了学习套件：树莓派4B、Codesys 许可证和《开放式控制系统编程技术》这本书。&lt;/p&gt;&lt;p&gt;五一假期试玩了一把。以下凭借记忆叙述大致步骤，作为备忘，也希望帮助从搜索引擎过来的朋友。&lt;/p&gt;&lt;p&gt;目录：&lt;/p&gt;&lt;p&gt;树莓派的相关操作，例如配置 ssh / vnc server、配置网络接口 eth0 等操作不在此赘述，可参考 &lt;/p&gt;&lt;p&gt;大致步骤：&lt;/p&gt;&lt;p&gt;完成授权后启动 runtime，尝试新建工程并下载，确保正常工作，至此树莓派变身为一台软 PLC。&lt;/p&gt;&lt;p&gt;使用网络交换机将设备连接到一起，我的设备情况如下。&lt;/p&gt;&lt;p&gt;注意：我遇到了树莓派的 eth0 无法 ping 通外部设备的情况。搜索后执行了 &lt;/p&gt;&lt;p&gt;下载、安装设备的 GSD 文件操作，这里也不提。&lt;/p&gt;&lt;p&gt;关键步骤：&lt;/p&gt;&lt;p&gt;硬件组态完成后，进行 I/O 映射。&lt;/p&gt;&lt;p&gt;我使用的硬件：BK9053 耦合器 &lt;/p&gt;&lt;p&gt;完成映射后发现无法手动强制信号……最后发现用代码置位信号后，可以手动强制了，不解。&lt;/p&gt;&lt;p&gt;最后录制了一个“跑马灯”效果的 demo：循环点亮每个数字输出通道。&lt;/p&gt;&lt;p&gt;https://v.youku.com/v_show/id_XNDY2MzY4MjAzMg==.html&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;最近公司让我紧急做个 FANUC 机器人的拆垛仿真，需要：&lt;/p&gt;&lt;p&gt;前者这条约束，导致没法用 RoboDK 这样的第三方软件。&lt;/p&gt;&lt;p&gt;于是不得不用 FANUC 的 Roboguide 了，虽然我接触 FANUC 好些年了，但只用 Roboguide 做程序代码的仿真和基本的布局验证。&lt;/p&gt;&lt;p&gt;好一顿折腾，记录如下。&lt;/p&gt;&lt;p&gt;我会从本次任务中抽取几个主题，构成本文内容：&lt;/p&gt;&lt;p&gt;除去机器人模型外，需要若干基本模型，用于支持仿真。例如，搬运对象：箱子（立方体）；托盘；机器人工具（吸盘）。&lt;/p&gt;&lt;p&gt;可以通过文件来导入，也可以在 Roboguide 内进行简单几何体的建模。模型导入或创建完毕后，依据布局图进行相应的模型摆放。&lt;/p&gt;&lt;p&gt;如何安装机器人工具这类操作，不在此赘述，请查找自带的帮助文档，或者按照你习惯的操作进行探索。&lt;/p&gt;&lt;p&gt;Roboguide 给框定的操作逻辑是，用户先想好导入的模型是什么类别（machine / fixture / part / obstacle），然后再导入。&lt;/p&gt;&lt;p&gt;摘录自帮助文档的《Working with Parts》章节：&lt;/p&gt;&lt;p&gt;例如，已经导入了类别为 Part 的模型，但是它不能直接使用；用户需要将它与夹具或机器人工具关联。&lt;/p&gt;&lt;p&gt;下表为手工生成垛型的操作。&lt;/p&gt;&lt;p&gt;为了实现仿真抓放，我们先配置机器人工具以实现抓取、放置的动画效果，下表的操作将机器人工具（EOAT）与 parts 关联。&lt;/p&gt;&lt;p&gt;将机器人工具与 part 关联后，如何实现 attach / detach 呢？Roboguide 提供了一种特别类型的程序，叫做仿真程序（Simulation program）；它与真实的机器人程序（TPE / KAREL 程序）不同，只能用于仿真环境。&lt;/p&gt;&lt;p&gt;从 Teach 菜单添加仿真程序，例如 &lt;/p&gt;&lt;p&gt;同理，可以添加放置的程序（使用 &lt;/p&gt;&lt;p&gt;终于到了综合部分：如何让机器人运动到某个位姿，抓取箱子，运动到另一个位姿，放置箱子。&lt;/p&gt;&lt;p&gt;如果抓取位姿、放置位姿都是固定的，那么很简单：添加仿真程序，插入类似 &lt;/p&gt;&lt;p&gt;但是本任务的特点是：&lt;/p&gt;&lt;p&gt;好，这“一推一拉”的形势，决定了我们肯定要用聪明些的方法。&lt;/p&gt;&lt;p&gt;帮助文档的《Teach a program》章含有 Combining simulation and TP programs into a single animation program 小节，完成本任务需要用到仿真程序和机器人程序的结合。因为仿真程序（Simulation program）的指令和能力非常有限。&lt;/p&gt;&lt;p&gt;我的思路为，得到箱子位姿后，设法计算、生成两个机器人程序（&lt;/p&gt;&lt;p&gt;细心的读者会发现，在仿真程序中使用了全局的数字寄存器 &lt;/p&gt;&lt;p&gt;5.3 节得到了箱子参考托盘的位姿，实际使用时应该把箱子位姿变换到机器人世界坐标系下面：托盘位姿是已知的，所以箱子的绝对位姿是可以在外部算出来的。&lt;/p&gt;&lt;p&gt;得到箱子的绝对位姿后，至少要按照箱子的 Z 值排序，以便进行从高到低的拆垛（废话）。当吸盘比箱子大时，同层的箱子也不能随便吸取，否则就露馅了；而是应当用吸盘边角去吸取。这个涉及到计算，为了减少麻烦，本次通过设置机器人工具的 part offset 来规避。&lt;/p&gt;&lt;p&gt;到这里，我们已经手握 36 个处理后（排序）的箱子位姿，就可以根据如下的 FANUC TPE 程序的模板来生成 &lt;/p&gt;&lt;p&gt;科普：TPE 程序的源文件后缀为 &lt;/p&gt;&lt;p&gt;至此，仿真程序就能调用生成的机器人程序（包含接近、吸取、离开箱子的位姿），实现精确运动到每个箱子上表面，抓取和放置了。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;近期出差发生了一件很有意思的事情。&lt;/p&gt;&lt;p&gt;工控机上跑着一个命令行程序（该程序具备网络通信功能），它会频繁打印信息到标准输出。由于需要定期查看输出的最新信息，我们习惯按住鼠标左键拖选关键输出（此时进入了 cmd.exe 的快速编辑模式），这样就能高亮显示了，阅读起来轻松些。&lt;/p&gt;&lt;p&gt;看完输出后，人就走开了（此时仍然维持着快速编辑模式）。&lt;/p&gt;&lt;p&gt;不久，我们发现似乎程序在某个时间点，本该收到外部网络数据，但是迟迟收不到。纳闷。&lt;/p&gt;&lt;p&gt;于是不得不中断设备的运行，切到手动模式操作。&lt;/p&gt;&lt;p&gt;后来同事提及，他碰到过类似事情，最后发现在选中 cmd.exe 的输出时，会阻塞程序的运行。&lt;/p&gt;&lt;p&gt;我写了几行代码验证，果然如此。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;许久没做 KRC4 的编程，其实当前工作上也不需要，只是想强制自己练练手。&lt;/p&gt;&lt;p&gt;在写了几十行代码后，我想将机器人本体可视化出来，这样能带来直观的调试感受。因为我没有 KUKA.Sim，所以想到用 RoboDK 来做这件事情。&lt;/p&gt;&lt;p&gt;解释一下：&lt;/p&gt;&lt;p&gt;如果你不喜欢使用这套私有的连接技术，可自行使用 TCP/IP socket 来实现；那么你就需要在 KRC 中安装 Ethernet KRL 来让库卡的编程语言（KRL）具备网络通信能力，同时在 PC 端利用 RoboDK 的脚本功能实现网络通信。&lt;/p&gt;&lt;p&gt;要想可视化机器人运动，只要能快速频繁地读取机器人的各关节度数就行。对于 KRC，就是频繁读取系统变量 &lt;/p&gt;&lt;p&gt;RoboDK API: &lt;/p&gt;&lt;p&gt;当然，需要先创建带有 KUKA 机器人的 RoboDK 工程，请使用 KR 210-2 这款本体，它是 OfficeLite 使用的本体型号。&lt;/p&gt;&lt;p&gt;我在 RoboDK 中创建了两个脚本，一个是定期频繁读取机器人关节读数的脚本（&lt;/p&gt;&lt;p&gt;优酷&lt;/p&gt;&lt;p&gt;Youtube&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;PLB 是 SICK 的视觉产品，可以理解为一套软硬件结合的系统，全称是 Part Localization in Bins，即箱中工件定位。它用于引导机器人实现 &lt;/p&gt;&lt;p&gt;和 SICK China 合作，我实现了 FANUC（发那科） 和 KAWASAKI（川崎）的通信接口和代码示例，覆盖了 PLB 5.2 的基础功能。&lt;/p&gt;&lt;p&gt;本文仅涉及 PLB 中的几个坐标系，对初入 3D 视觉的朋友也许会有帮助。内容和截图来源于 PLB 5.2 版本操作手册中的 3.2.4 Reference frames 章节。&lt;/p&gt;&lt;p&gt;PLB 最终将计算出“工件坐标系（相对于机器人坐标系）”和“抓手相对于工件坐标系的位姿”。&lt;/p&gt;&lt;p&gt;A 是工件数模中的参考坐标系，B 是调整后的坐标系。part frame 的数值是相对于机器人坐标系的（事先需要完成标定），由 PLB 计算而来。&lt;/p&gt;&lt;p&gt;A 是抓手数模中的参考坐标系，C 是调整过后的坐标系（原点需要和真实的 TCP 重合），B 是 A ---&gt; C 的变换。&lt;/p&gt;&lt;p&gt;A 是调整过后的抓手坐标系，B 是调整过后的工件坐标系。&lt;/p&gt;&lt;p&gt;如果是相对简单的应用，可以让 PLB 为你计算好真正的 pick pose（即 absolute tool frame），在机器人接口中指定使用 absolute tool frame 即可。&lt;/p&gt;&lt;p&gt;但是在使用相对工具坐标系（relative tool frame）时，PLB 输出的数据不能直接让机器人运动过去，而是需要先自行做变换，见&lt;/p&gt;&lt;p&gt;更复杂的情况是，某些工件从横截面看是轴对称的，只需要一种抓取姿态就可以应付；为此 PLB 引入了 vertical correction，即垂直校正。那么，这时：&lt;/p&gt;&lt;p&gt;摘取 PLB 5.2 机器人接口支持的字段。    &lt;/p&gt;&lt;p&gt;拓展：为了放工件时更加灵活和优雅，也可以根据这些坐标系数据计算出一个新的机器人工具数据，新工具的 TCP 与工件的坐标系原点重合。手册里并没有指出如何变换。&lt;/p&gt;&lt;p&gt;但这实际上就是求出 tool 1 ---&gt; tool 2 的变换关系 T。&lt;/p&gt;&lt;p&gt;
[ &lt;/p&gt;&lt;p&gt;Preface: try to write this topic in english.&lt;/p&gt;&lt;p&gt;Let&#x27; say we have a string &lt;/p&gt;&lt;p&gt;We got the unix-timestamp representation: &lt;/p&gt;&lt;p&gt;Karel timestamp is not the same as unix&#x27;s.  The same time &lt;/p&gt;&lt;p&gt;And the built-in function &lt;/p&gt;&lt;p&gt;Note: 2018 = 1980 (year starts from 1980 in karel) + 38&lt;/p&gt;&lt;p&gt;so the binary form of &lt;/p&gt;&lt;p&gt;We can use mask and shift to extract year, month, ...  Karel has no SHIFT operator, so use &lt;/p&gt;&lt;p&gt;Karel code:&lt;/p&gt;&lt;p&gt;Feel free to use code above, modify them to suit your scenario.&lt;/p&gt;
                ]]>
        </content>
        </entry>

</feed>